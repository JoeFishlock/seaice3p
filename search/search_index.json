{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"API Reference","text":""},{"location":"#seaice3p.BRW09Forcing","title":"<code>BRW09Forcing</code>","text":"<p>Surface and ocean temperature data loaded from thermistor temperature record during the Barrow 2009 field study.</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\nclass BRW09Forcing:\n    \"\"\"Surface and ocean temperature data loaded from thermistor temperature record\n    during the Barrow 2009 field study.\n    \"\"\"\n\n    Barrow_top_temperature_data_choice: str = \"air\"\n\n    def __post_init__(self):\n        \"\"\"populate class attributes with barrow dimensional air temperature\n        and time in days (with missing values filtered out).\n\n        Note the metadata explaining how to use the barrow temperature data is also\n        in seaice3p/forcing_data. The indices corresponding to days and air temp are\n        hard coded in as class variables.\n        \"\"\"\n        DATA_INDICES = {\n            \"time\": 0,\n            \"air\": 8,\n            \"bottom_snow\": 18,\n            \"top_ice\": 19,\n        }\n        data = np.genfromtxt(\n            Path(__file__).parent.parent / \"forcing_data/BRW09.txt\", delimiter=\"\\t\"\n        )\n        top_temp_index = DATA_INDICES[self.Barrow_top_temperature_data_choice]\n        time_index = DATA_INDICES[\"time\"]\n\n        barrow_top_temp = data[:, top_temp_index]\n        barrow_days = data[:, time_index] - data[0, time_index]\n        barrow_top_temp, barrow_days = _filter_missing_values(\n            barrow_top_temp, barrow_days\n        )\n\n        self.barrow_top_temp = barrow_top_temp\n        self.barrow_days = barrow_days\n</code></pre>"},{"location":"#seaice3p.BRW09Forcing.__post_init__","title":"<code>__post_init__()</code>","text":"<p>populate class attributes with barrow dimensional air temperature and time in days (with missing values filtered out).</p> <p>Note the metadata explaining how to use the barrow temperature data is also in seaice3p/forcing_data. The indices corresponding to days and air temp are hard coded in as class variables.</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>def __post_init__(self):\n    \"\"\"populate class attributes with barrow dimensional air temperature\n    and time in days (with missing values filtered out).\n\n    Note the metadata explaining how to use the barrow temperature data is also\n    in seaice3p/forcing_data. The indices corresponding to days and air temp are\n    hard coded in as class variables.\n    \"\"\"\n    DATA_INDICES = {\n        \"time\": 0,\n        \"air\": 8,\n        \"bottom_snow\": 18,\n        \"top_ice\": 19,\n    }\n    data = np.genfromtxt(\n        Path(__file__).parent.parent / \"forcing_data/BRW09.txt\", delimiter=\"\\t\"\n    )\n    top_temp_index = DATA_INDICES[self.Barrow_top_temperature_data_choice]\n    time_index = DATA_INDICES[\"time\"]\n\n    barrow_top_temp = data[:, top_temp_index]\n    barrow_days = data[:, time_index] - data[0, time_index]\n    barrow_top_temp, barrow_days = _filter_missing_values(\n        barrow_top_temp, barrow_days\n    )\n\n    self.barrow_top_temp = barrow_top_temp\n    self.barrow_days = barrow_days\n</code></pre>"},{"location":"#seaice3p.BRW09InitialConditions","title":"<code>BRW09InitialConditions</code>  <code>dataclass</code>","text":"<p>values for bottom (ocean) boundary</p> Source code in <code>seaice3p/params/dimensional/initial_conditions.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass BRW09InitialConditions:\n    \"\"\"values for bottom (ocean) boundary\"\"\"\n\n    Barrow_initial_bulk_gas_in_ice: float = 1 / 5\n</code></pre>"},{"location":"#seaice3p.BRW09OceanForcing","title":"<code>BRW09OceanForcing</code>","text":"<p>Ocean temperature provided by Barrow 2009 data at 2.4m and specify ocean fixed gas saturation state</p> Source code in <code>seaice3p/params/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\nclass BRW09OceanForcing:\n    \"\"\"Ocean temperature provided by Barrow 2009 data at 2.4m and specify ocean\n    fixed gas saturation state\"\"\"\n\n    ocean_gas_sat: float = 1.0\n\n    def __post_init__(self):\n        \"\"\"populate class attributes with barrow dimensional ocean temperature\n        and time in days (with missing values filtered out).\n\n        Note the metadata explaining how to use the barrow temperature data is also\n        in seaice3p/forcing_data.\n        \"\"\"\n        data = np.genfromtxt(\n            Path(__file__).parent.parent / \"forcing_data/BRW09.txt\", delimiter=\"\\t\"\n        )\n        ocean_temp_index = 43\n        time_index = 0\n\n        barrow_bottom_temp = data[:, ocean_temp_index]\n        barrow_ocean_days = data[:, time_index] - data[0, time_index]\n        barrow_bottom_temp, barrow_ocean_days = _filter_missing_values(\n            barrow_bottom_temp, barrow_ocean_days\n        )\n\n        self.barrow_bottom_temp = barrow_bottom_temp\n        self.barrow_ocean_days = barrow_ocean_days\n</code></pre>"},{"location":"#seaice3p.BRW09OceanForcing.__post_init__","title":"<code>__post_init__()</code>","text":"<p>populate class attributes with barrow dimensional ocean temperature and time in days (with missing values filtered out).</p> <p>Note the metadata explaining how to use the barrow temperature data is also in seaice3p/forcing_data.</p> Source code in <code>seaice3p/params/ocean_forcing.py</code> <pre><code>def __post_init__(self):\n    \"\"\"populate class attributes with barrow dimensional ocean temperature\n    and time in days (with missing values filtered out).\n\n    Note the metadata explaining how to use the barrow temperature data is also\n    in seaice3p/forcing_data.\n    \"\"\"\n    data = np.genfromtxt(\n        Path(__file__).parent.parent / \"forcing_data/BRW09.txt\", delimiter=\"\\t\"\n    )\n    ocean_temp_index = 43\n    time_index = 0\n\n    barrow_bottom_temp = data[:, ocean_temp_index]\n    barrow_ocean_days = data[:, time_index] - data[0, time_index]\n    barrow_bottom_temp, barrow_ocean_days = _filter_missing_values(\n        barrow_bottom_temp, barrow_ocean_days\n    )\n\n    self.barrow_bottom_temp = barrow_bottom_temp\n    self.barrow_ocean_days = barrow_ocean_days\n</code></pre>"},{"location":"#seaice3p.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>contains all information needed to run a simulation and save output</p> <p>this config object can be saved and loaded to a yaml file.</p> Source code in <code>seaice3p/params/params.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass Config:\n    \"\"\"contains all information needed to run a simulation and save output\n\n    this config object can be saved and loaded to a yaml file.\"\"\"\n\n    name: str\n    total_time: float\n    savefreq: float\n\n    physical_params: PhysicalParams\n    bubble_params: BubbleParams\n    brine_convection_params: BrineConvectionParams\n    forcing_config: ForcingConfig\n    ocean_forcing_config: OceanForcingConfig\n    initial_conditions_config: InitialConditionsConfig\n    numerical_params: NumericalParams = NumericalParams()\n    scales: Scales | None = None\n\n    def save(self, directory: Path):\n        with open(directory / f\"{self.name}.yml\", \"w\") as outfile:\n            outfile.write(to_yaml(self))\n\n    @classmethod\n    def load(cls, path):\n        with open(path, \"r\") as infile:\n            yaml = infile.read()\n        return from_yaml(cls, yaml)\n</code></pre>"},{"location":"#seaice3p.ConstantForcing","title":"<code>ConstantForcing</code>  <code>dataclass</code>","text":"<p>Constant temperature forcing</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass ConstantForcing:\n    \"\"\"Constant temperature forcing\"\"\"\n\n    constant_top_temperature: float = -1.5\n</code></pre>"},{"location":"#seaice3p.CubicLiquidus","title":"<code>CubicLiquidus</code>  <code>dataclass</code>","text":"<p>Cubic fit to liquidus to give liquidus salinity in terms of temperature</p> <p>S = a0 + a1 T + a2 T^2 + a3 T^3</p> <p>defaults are taken from Notz PhD thesis for fit to Assur seawater data</p> Source code in <code>seaice3p/params/dimensional/water.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass CubicLiquidus:\n    \"\"\"Cubic fit to liquidus to give liquidus salinity in terms of temperature\n\n    S = a0 + a1 T + a2 T^2 + a3 T^3\n\n    defaults are taken from Notz PhD thesis for fit to Assur seawater data\n    \"\"\"\n\n    eutectic_temperature: float = -21.1  # deg Celsius\n    a0: float = -1.2\n    a1: float = -21.8\n    a2: float = -0.919\n    a3: float = -0.0178\n\n    def get_liquidus_salinity(self, temperature):\n        return (\n            self.a0\n            + self.a1 * temperature\n            + self.a2 * temperature**2\n            + self.a3 * temperature**3\n        )\n\n    def get_liquidus_temperature(self, salinity):\n        temperature = fsolve(\n            lambda x: salinity - self.get_liquidus_salinity(x),\n            np.full_like(salinity, -2),\n        )\n        if temperature.size == 1:\n            return temperature[0]\n        else:\n            return temperature\n</code></pre>"},{"location":"#seaice3p.DISEQPhysicalParams","title":"<code>DISEQPhysicalParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BasePhysicalParams</code></p> <p>non dimensional numbers for the mushy layer</p> Source code in <code>seaice3p/params/physical.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DISEQPhysicalParams(BasePhysicalParams):\n    \"\"\"non dimensional numbers for the mushy layer\"\"\"\n\n    # only used in DISEQ model\n    damkohler_number: float = 1\n</code></pre>"},{"location":"#seaice3p.DimensionalBRW09OceanForcing","title":"<code>DimensionalBRW09OceanForcing</code>  <code>dataclass</code>","text":"<p>Ocean temperature provided by Barrow 2009 data at 2.4m and specify ocean fixed gas saturation state</p> Source code in <code>seaice3p/params/dimensional/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalBRW09OceanForcing:\n    \"\"\"Ocean temperature provided by Barrow 2009 data at 2.4m and specify ocean\n    fixed gas saturation state\"\"\"\n\n    pass\n</code></pre>"},{"location":"#seaice3p.DimensionalConstantTurbulentFlux","title":"<code>DimensionalConstantTurbulentFlux</code>  <code>dataclass</code>","text":"<p>Parameters for calculating the turbulent surface sensible and latent heat fluxes</p> <p>NOTE: If you are running a simulation with ERA5 reanalysis forcing you must set the ref_height=2m as this is the appropriate value for the atmospheric reanalysis quantities</p> Source code in <code>seaice3p/params/dimensional/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalConstantTurbulentFlux:\n    \"\"\"Parameters for calculating the turbulent surface sensible and latent heat\n    fluxes\n\n    NOTE: If you are running a simulation with ERA5 reanalysis forcing you must set\n    the ref_height=2m as this is the appropriate value for the atmospheric reanalysis\n    quantities\n    \"\"\"\n\n    ref_height: float = 10  # m\n    windspeed: float = 5  # m/s\n    air_temp: float = 0  # deg C\n    specific_humidity: float = 3.6e-3  # kg water / kg air\n    atm_pressure: float = 101.325  # KPa\n\n    air_density: float = 1.275  # kg/m3\n    air_heat_capacity: float = 1005  # J/kg K\n    air_latent_heat_of_vaporisation: float = 2.501e6  # J/kg\n</code></pre>"},{"location":"#seaice3p.DimensionalERA5Forcing","title":"<code>DimensionalERA5Forcing</code>","text":"<p>read ERA5 data from netCDF file located at data_path.</p> <p>Simulation will take atmospheric forcings from the start date specified in the format YYYY-MM-DD</p> Source code in <code>seaice3p/params/dimensional/forcing.py</code> <pre><code>@serde(type_check=coerce)\nclass DimensionalERA5Forcing:\n    \"\"\"read ERA5 data from netCDF file located at data_path.\n\n    Simulation will take atmospheric forcings from the start date specified in the\n    format YYYY-MM-DD\n    \"\"\"\n\n    data_path: Path\n    start_date: str  # YYYY-MM-DD\n    use_snow_data: bool = False\n    SW_forcing: DimensionalSWForcing = DimensionalConstantSWForcing()\n    LW_forcing: DimensionalLWForcing = DimensionalConstantLWForcing()\n    turbulent_flux: DimensionalTurbulentFlux = DimensionalConstantTurbulentFlux()\n    oil_heating: DimensionalOilHeating = DimensionalBackgroundOilHeating()\n</code></pre>"},{"location":"#seaice3p.DimensionalFixedHeatFluxOceanForcing","title":"<code>DimensionalFixedHeatFluxOceanForcing</code>  <code>dataclass</code>","text":"<p>Provides constant ocean heat flux at the bottom of the domain</p> <p>Parameters:</p> Name Type Description Default <code>ocean_heat_flux</code> <code>float</code> <p>The constant heat flux at the bottom of the domain in W/m2</p> <code>1</code> Source code in <code>seaice3p/params/dimensional/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalFixedHeatFluxOceanForcing:\n    \"\"\"Provides constant ocean heat flux at the bottom of the domain\n\n    Args:\n        ocean_heat_flux: The constant heat flux at the bottom of the domain in W/m2\n    \"\"\"\n\n    ocean_heat_flux: float = 1\n</code></pre>"},{"location":"#seaice3p.DimensionalFixedTempOceanForcing","title":"<code>DimensionalFixedTempOceanForcing</code>  <code>dataclass</code>","text":"<p>Fixed temperature and gas saturation ocean boundary condition</p> Source code in <code>seaice3p/params/dimensional/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalFixedTempOceanForcing:\n    \"\"\"Fixed temperature and gas saturation ocean boundary condition\"\"\"\n\n    ocean_temp: float = -1\n</code></pre>"},{"location":"#seaice3p.DimensionalMonoBubbleParams","title":"<code>DimensionalMonoBubbleParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DimensionalBaseBubbleParams</code></p> Source code in <code>seaice3p/params/dimensional/bubble.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalMonoBubbleParams(DimensionalBaseBubbleParams):\n    bubble_radius: float = 1e-3  # bubble radius in m\n\n    @property\n    def bubble_radius_scaled(self):\n        r\"\"\"calculate the bubble radius divided by the pore scale\n\n        .. math:: \\Lambda = R_B / R_0\n\n        \"\"\"\n        return self.bubble_radius / self.pore_radius\n</code></pre>"},{"location":"#seaice3p.DimensionalMonoBubbleParams.bubble_radius_scaled","title":"<code>bubble_radius_scaled</code>  <code>property</code>","text":"<p>calculate the bubble radius divided by the pore scale</p> <p>.. math:: \\Lambda = R_B / R_0</p>"},{"location":"#seaice3p.DimensionalParams","title":"<code>DimensionalParams</code>  <code>dataclass</code>","text":"<p>Contains all dimensional parameters needed to calculate non dimensional numbers.</p> <p>To see the units each input should have look at the comment next to the default value.</p> Source code in <code>seaice3p/params/dimensional/dimensional.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalParams:\n    \"\"\"Contains all dimensional parameters needed to calculate non dimensional numbers.\n\n    To see the units each input should have look at the comment next to the default\n    value.\n    \"\"\"\n\n    name: str\n    total_time_in_days: float\n    savefreq_in_days: float\n    lengthscale: float\n\n    gas_params: DimensionalEQMGasParams | DimensionalDISEQGasParams\n    bubble_params: DimensionalMonoBubbleParams | DimensionalPowerLawBubbleParams\n    brine_convection_params: DimensionalRJW14Params | NoBrineConvection\n    forcing_config: DimensionalRadForcing | DimensionalBRW09Forcing | DimensionalConstantForcing | DimensionalYearlyForcing | DimensionalRobinForcing | DimensionalERA5Forcing\n    ocean_forcing_config: DimensionalBRW09OceanForcing | DimensionalFixedTempOceanForcing | DimensionalFixedHeatFluxOceanForcing\n    initial_conditions_config: DimensionalOilInitialConditions | UniformInitialConditions | BRW09InitialConditions | PreviousSimulation\n\n    water_params: DimensionalWaterParams = DimensionalWaterParams()\n    numerical_params: NumericalParams = NumericalParams()\n    frame_velocity_dimensional: float = 0  # velocity of frame in m/day\n    gravity: float = 9.81  # m/s2\n\n    @property\n    def damkohler_number(self):\n        r\"\"\"Return damkohler number as ratio of thermal timescale to nucleation\n        timescale\n        \"\"\"\n        if isinstance(self.gas_params, DimensionalEQMGasParams):\n            return None\n\n        return (\n            (self.lengthscale**2) / self.water_params.thermal_diffusivity\n        ) / self.gas_params.nucleation_timescale\n\n    @property\n    def total_time(self):\n        \"\"\"calculate the total time in non dimensional units for the simulation\"\"\"\n        return self.total_time_in_days / self.scales.time_scale\n\n    @property\n    def savefreq(self):\n        \"\"\"calculate the save frequency in non dimensional time\"\"\"\n        return self.savefreq_in_days / self.scales.time_scale\n\n    @property\n    def frame_velocity(self):\n        \"\"\"calculate the frame velocity in non dimensional units\"\"\"\n        return self.frame_velocity_dimensional / self.scales.velocity_scale\n\n    @property\n    def B(self):\n        r\"\"\"calculate the non dimensional scale for buoyant rise of gas bubbles as\n\n        .. math:: \\mathcal{B} = \\frac{\\rho_l g R_0^2 h}{3 \\mu \\kappa}\n\n        \"\"\"\n        stokes_velocity = (\n            (self.water_params.liquid_density - self.gas_params.gas_density)\n            * self.gravity\n            * self.bubble_params.pore_radius**2\n            / (3 * self.water_params.liquid_viscosity)\n        )\n        velocity_scale_in_m_per_second = (\n            self.water_params.thermal_diffusivity / self.lengthscale\n        )\n        return stokes_velocity / velocity_scale_in_m_per_second\n\n    @property\n    def Rayleigh_salt(self):\n        r\"\"\"Calculate the haline Rayleigh number as\n\n        .. math:: \\text{Ra}_S = \\frac{\\rho_l g \\beta \\Delta S H K_0}{\\kappa \\mu}\n\n        \"\"\"\n        match self.brine_convection_params:\n            case DimensionalRJW14Params():\n                return (\n                    self.water_params.liquid_density\n                    * self.gravity\n                    * self.water_params.haline_contraction_coefficient\n                    * self.water_params.salinity_difference\n                    * self.lengthscale\n                    * self.brine_convection_params.reference_permeability\n                    / (\n                        self.water_params.thermal_diffusivity\n                        * self.water_params.liquid_viscosity\n                    )\n                )\n            case NoBrineConvection():\n                return None\n\n    @property\n    def expansion_coefficient(self):\n        r\"\"\"calculate\n\n        .. math:: \\chi = \\rho_l \\xi_{\\text{sat}} / \\rho_g\n\n        \"\"\"\n        return (\n            self.water_params.liquid_density\n            * self.gas_params.saturation_concentration\n            / self.gas_params.gas_density\n        )\n\n    @property\n    def lewis_gas(self):\n        r\"\"\"Calculate the lewis number for dissolved gas, return np.inf if there is no\n        dissolved gas diffusion.\n\n        .. math:: \\text{Le}_\\xi = \\kappa / D_\\xi\n\n        \"\"\"\n        if self.gas_params.gas_diffusivity == 0:\n            return np.inf\n\n        return self.water_params.thermal_diffusivity / self.gas_params.gas_diffusivity\n\n    @property\n    def scales(self):\n        \"\"\"return a Scales object used for converting between dimensional and non\n        dimensional variables.\"\"\"\n        return Scales(\n            self.lengthscale,\n            self.water_params.thermal_diffusivity,\n            self.water_params.liquid_thermal_conductivity,\n            self.water_params.ocean_salinity,\n            self.water_params.salinity_difference,\n            self.water_params.ocean_freezing_temperature,\n            self.water_params.temperature_difference,\n            self.gas_params.gas_density,\n            self.water_params.liquid_density,\n            self.water_params.ice_density,\n            self.gas_params.saturation_concentration,\n            self.bubble_params.pore_radius,\n            self.water_params.haline_contraction_coefficient,\n        )\n\n    def save(self, directory: Path):\n        \"\"\"save this object to a yaml file in the specified directory.\n\n        The name will be the name given with _dimensional appended to distinguish it\n        from a saved non-dimensional configuration.\"\"\"\n        with open(directory / f\"{self.name}_dimensional.yml\", \"w\") as outfile:\n            outfile.write(to_yaml(self))\n\n    @classmethod\n    def load(cls, path):\n        \"\"\"load this object from a yaml configuration file.\"\"\"\n        with open(path, \"r\") as infile:\n            yaml = infile.read()\n        return from_yaml(cls, yaml)\n</code></pre>"},{"location":"#seaice3p.DimensionalParams.B","title":"<code>B</code>  <code>property</code>","text":"<p>calculate the non dimensional scale for buoyant rise of gas bubbles as</p> <p>.. math:: \\mathcal{B} = \\frac{\\rho_l g R_0^2 h}{3 \\mu \\kappa}</p>"},{"location":"#seaice3p.DimensionalParams.Rayleigh_salt","title":"<code>Rayleigh_salt</code>  <code>property</code>","text":"<p>Calculate the haline Rayleigh number as</p> <p>.. math:: \\text{Ra}_S = \\frac{\\rho_l g \\beta \\Delta S H K_0}{\\kappa \\mu}</p>"},{"location":"#seaice3p.DimensionalParams.damkohler_number","title":"<code>damkohler_number</code>  <code>property</code>","text":"<p>Return damkohler number as ratio of thermal timescale to nucleation timescale</p>"},{"location":"#seaice3p.DimensionalParams.expansion_coefficient","title":"<code>expansion_coefficient</code>  <code>property</code>","text":"<p>calculate</p> <p>.. math:: \\chi = \\rho_l \\xi_{\\text{sat}} / \\rho_g</p>"},{"location":"#seaice3p.DimensionalParams.frame_velocity","title":"<code>frame_velocity</code>  <code>property</code>","text":"<p>calculate the frame velocity in non dimensional units</p>"},{"location":"#seaice3p.DimensionalParams.lewis_gas","title":"<code>lewis_gas</code>  <code>property</code>","text":"<p>Calculate the lewis number for dissolved gas, return np.inf if there is no dissolved gas diffusion.</p> <p>.. math:: \\text{Le}\\xi = \\kappa / D\\xi</p>"},{"location":"#seaice3p.DimensionalParams.savefreq","title":"<code>savefreq</code>  <code>property</code>","text":"<p>calculate the save frequency in non dimensional time</p>"},{"location":"#seaice3p.DimensionalParams.scales","title":"<code>scales</code>  <code>property</code>","text":"<p>return a Scales object used for converting between dimensional and non dimensional variables.</p>"},{"location":"#seaice3p.DimensionalParams.total_time","title":"<code>total_time</code>  <code>property</code>","text":"<p>calculate the total time in non dimensional units for the simulation</p>"},{"location":"#seaice3p.DimensionalParams.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>load this object from a yaml configuration file.</p> Source code in <code>seaice3p/params/dimensional/dimensional.py</code> <pre><code>@classmethod\ndef load(cls, path):\n    \"\"\"load this object from a yaml configuration file.\"\"\"\n    with open(path, \"r\") as infile:\n        yaml = infile.read()\n    return from_yaml(cls, yaml)\n</code></pre>"},{"location":"#seaice3p.DimensionalParams.save","title":"<code>save(directory)</code>","text":"<p>save this object to a yaml file in the specified directory.</p> <p>The name will be the name given with _dimensional appended to distinguish it from a saved non-dimensional configuration.</p> Source code in <code>seaice3p/params/dimensional/dimensional.py</code> <pre><code>def save(self, directory: Path):\n    \"\"\"save this object to a yaml file in the specified directory.\n\n    The name will be the name given with _dimensional appended to distinguish it\n    from a saved non-dimensional configuration.\"\"\"\n    with open(directory / f\"{self.name}_dimensional.yml\", \"w\") as outfile:\n        outfile.write(to_yaml(self))\n</code></pre>"},{"location":"#seaice3p.DimensionalPowerLawBubbleParams","title":"<code>DimensionalPowerLawBubbleParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DimensionalBaseBubbleParams</code></p> Source code in <code>seaice3p/params/dimensional/bubble.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalPowerLawBubbleParams(DimensionalBaseBubbleParams):\n    bubble_distribution_power: float = 1.5\n    minimum_bubble_radius: float = 1e-6\n    maximum_bubble_radius: float = 1e-3\n\n    @property\n    def minimum_bubble_radius_scaled(self):\n        r\"\"\"calculate the bubble radius divided by the pore scale\n\n        .. math:: \\Lambda = R_B / R_0\n\n        \"\"\"\n        return self.minimum_bubble_radius / self.pore_radius\n\n    @property\n    def maximum_bubble_radius_scaled(self):\n        r\"\"\"calculate the bubble radius divided by the pore scale\n\n        .. math:: \\Lambda = R_B / R_0\n\n        \"\"\"\n        return self.maximum_bubble_radius / self.pore_radius\n</code></pre>"},{"location":"#seaice3p.DimensionalPowerLawBubbleParams.maximum_bubble_radius_scaled","title":"<code>maximum_bubble_radius_scaled</code>  <code>property</code>","text":"<p>calculate the bubble radius divided by the pore scale</p> <p>.. math:: \\Lambda = R_B / R_0</p>"},{"location":"#seaice3p.DimensionalPowerLawBubbleParams.minimum_bubble_radius_scaled","title":"<code>minimum_bubble_radius_scaled</code>  <code>property</code>","text":"<p>calculate the bubble radius divided by the pore scale</p> <p>.. math:: \\Lambda = R_B / R_0</p>"},{"location":"#seaice3p.DimensionalRobinForcing","title":"<code>DimensionalRobinForcing</code>  <code>dataclass</code>","text":"<p>This forcing imposes a Robin boundary condition of the form surface_heat_flux=heat_transfer_coefficient * (restoring_temp - surface_temp)</p> Source code in <code>seaice3p/params/dimensional/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalRobinForcing:\n    \"\"\"This forcing imposes a Robin boundary condition of the form\n    surface_heat_flux=heat_transfer_coefficient * (restoring_temp - surface_temp)\n    \"\"\"\n\n    heat_transfer_coefficient: float = 6.3  # W/m2K\n    restoring_temperature: float = -30  # deg C\n</code></pre>"},{"location":"#seaice3p.DimensionalWaterParams","title":"<code>DimensionalWaterParams</code>  <code>dataclass</code>","text":"Source code in <code>seaice3p/params/dimensional/water.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalWaterParams:\n    liquid_density: float = 1028  # kg/m3\n    ice_density: float = 916  # kg/m3\n    ocean_salinity: float = 34  # g/kg\n    liquidus: LinearLiquidus | CubicLiquidus = LinearLiquidus()\n    latent_heat: float = 334e3  # latent heat of fusion for ice in J/kg\n    liquid_specific_heat_capacity: float = 4184  # J/kg degC\n    solid_specific_heat_capacity: float = 2009  # J/kg degC\n    liquid_thermal_conductivity: float = 0.54  # water thermal conductivity in W/m deg C\n    solid_thermal_conductivity: float = 2.22  # ice thermal conductivity in W/m deg C\n    snow_thermal_conductivity: float = 0.31  # snow thermal conductivity in W/m deg C\n    snow_density: float = 150  # snow density kg/m3\n\n    eddy_diffusivity: float = 0\n\n    salt_diffusivity: float = 0  # molecular diffusivity of salt in water in m2/s\n    # used to calculate Rayleigh number for convection and density contraction in liquid equation of state\n    haline_contraction_coefficient: float = 7.5e-4  # 1/ppt\n\n    # calculated from moreau et al 2014 value of kinematic viscosity for sewater 2.7e-6\n    # dynamic liquid_viscosity = 2.7e-6 * liquid_density\n    liquid_viscosity: float = 2.78e-3  # dynamic liquid viscosity in Pa.s\n\n    @property\n    def eutectic_salinity(self):\n        if isinstance(self.liquidus, LinearLiquidus):\n            return self.liquidus.eutectic_salinity\n        if isinstance(self.liquidus, CubicLiquidus):\n            return self.liquidus.get_liquidus_salinity(\n                self.liquidus.eutectic_temperature\n            )\n\n        raise NotImplementedError\n\n    @property\n    def eutectic_temperature(self):\n        if isinstance(self.liquidus, LinearLiquidus) or isinstance(\n            self.liquidus, CubicLiquidus\n        ):\n            return self.liquidus.eutectic_temperature\n\n        raise NotImplementedError\n\n    @property\n    def salinity_difference(self):\n        r\"\"\"calculate difference between eutectic salinity and typical ocean salinity\n\n        .. math:: \\Delta S = S_E - S_i\n\n        \"\"\"\n        return self.eutectic_salinity - self.ocean_salinity\n\n    @property\n    def ocean_freezing_temperature(self):\n        \"\"\"calculate salinity dependent freezing temperature using linear liquidus with\n        ocean salinity\n\n        .. math:: T_i = T_L(S_i) = T_E S_i / S_E\n\n        or using a cubic fit for the liquidus curve\n\n        \"\"\"\n        if isinstance(self.liquidus, LinearLiquidus):\n            return (\n                self.eutectic_temperature * self.ocean_salinity / self.eutectic_salinity\n            )\n        if isinstance(self.liquidus, CubicLiquidus):\n            return self.liquidus.get_liquidus_temperature(self.ocean_salinity)\n\n        raise NotImplementedError\n\n    @property\n    def temperature_difference(self):\n        r\"\"\"calculate\n\n        .. math:: \\Delta T = T_i - T_E\n\n        \"\"\"\n        return self.ocean_freezing_temperature - self.eutectic_temperature\n\n    @property\n    def concentration_ratio(self):\n        r\"\"\"Calculate concentration ratio as\n\n        .. math:: \\mathcal{C} = S_i / \\Delta S\n\n        \"\"\"\n        return self.ocean_salinity / self.salinity_difference\n\n    @property\n    def stefan_number(self):\n        r\"\"\"calculate Stefan number\n\n        .. math:: \\text{St} = L / c_p \\Delta T\n\n        \"\"\"\n        return self.latent_heat / (\n            self.temperature_difference * self.liquid_specific_heat_capacity\n        )\n\n    @property\n    def thermal_diffusivity(self):\n        r\"\"\"Return thermal diffusivity in m2/s\n\n        .. math:: \\kappa = \\frac{k}{\\rho_l c_p}\n\n        \"\"\"\n        return self.liquid_thermal_conductivity / (\n            self.liquid_density * self.liquid_specific_heat_capacity\n        )\n\n    @property\n    def conductivity_ratio(self):\n        r\"\"\"Calculate the ratio of solid to liquid thermal conductivity\n\n        .. math:: \\lambda = \\frac{k_s}{k_l}\n\n        \"\"\"\n        return self.solid_thermal_conductivity / self.liquid_thermal_conductivity\n\n    @property\n    def specific_heat_ratio(self):\n        r\"\"\"Calculate the ratio of solid to liquid specific heat capacities\n\n        .. math:: \\lambda = \\frac{c_{p,s}}{c_{p,l}}\n\n        \"\"\"\n        return self.solid_specific_heat_capacity / self.liquid_specific_heat_capacity\n\n    @property\n    def eddy_diffusivity_ratio(self):\n        r\"\"\"Calculate the ratio of eddy diffusivity to thermal diffusivity in\n        the liquid phase\n\n        .. math:: \\lambda = \\frac{\\kappa_\\text{turbulent}}{\\kappa_l}\n\n        \"\"\"\n        return self.eddy_diffusivity / self.thermal_diffusivity\n\n    @property\n    def snow_conductivity_ratio(self):\n        r\"\"\"Calculate the ratio of snow to liquid thermal conductivity\n\n        .. math:: \\lambda = \\frac{k_{sn}}{k_l}\n\n        \"\"\"\n        return self.snow_thermal_conductivity / self.liquid_thermal_conductivity\n\n    @property\n    def lewis_salt(self):\n        r\"\"\"Calculate the lewis number for salt, return np.inf if there is no salt\n        diffusion.\n\n        .. math:: \\text{Le}_S = \\kappa / D_s\n\n        \"\"\"\n        if self.salt_diffusivity == 0:\n            return np.inf\n\n        return self.thermal_diffusivity / self.salt_diffusivity\n</code></pre>"},{"location":"#seaice3p.DimensionalWaterParams.concentration_ratio","title":"<code>concentration_ratio</code>  <code>property</code>","text":"<p>Calculate concentration ratio as</p> <p>.. math:: \\mathcal{C} = S_i / \\Delta S</p>"},{"location":"#seaice3p.DimensionalWaterParams.conductivity_ratio","title":"<code>conductivity_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of solid to liquid thermal conductivity</p> <p>.. math:: \\lambda = \\frac{k_s}{k_l}</p>"},{"location":"#seaice3p.DimensionalWaterParams.eddy_diffusivity_ratio","title":"<code>eddy_diffusivity_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of eddy diffusivity to thermal diffusivity in the liquid phase</p> <p>.. math:: \\lambda = \\frac{\\kappa_\\text{turbulent}}{\\kappa_l}</p>"},{"location":"#seaice3p.DimensionalWaterParams.lewis_salt","title":"<code>lewis_salt</code>  <code>property</code>","text":"<p>Calculate the lewis number for salt, return np.inf if there is no salt diffusion.</p> <p>.. math:: \\text{Le}_S = \\kappa / D_s</p>"},{"location":"#seaice3p.DimensionalWaterParams.ocean_freezing_temperature","title":"<code>ocean_freezing_temperature</code>  <code>property</code>","text":"<p>calculate salinity dependent freezing temperature using linear liquidus with ocean salinity</p> <p>.. math:: T_i = T_L(S_i) = T_E S_i / S_E</p> <p>or using a cubic fit for the liquidus curve</p>"},{"location":"#seaice3p.DimensionalWaterParams.salinity_difference","title":"<code>salinity_difference</code>  <code>property</code>","text":"<p>calculate difference between eutectic salinity and typical ocean salinity</p> <p>.. math:: \\Delta S = S_E - S_i</p>"},{"location":"#seaice3p.DimensionalWaterParams.snow_conductivity_ratio","title":"<code>snow_conductivity_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of snow to liquid thermal conductivity</p> <p>.. math:: \\lambda = \\frac{k_{sn}}{k_l}</p>"},{"location":"#seaice3p.DimensionalWaterParams.specific_heat_ratio","title":"<code>specific_heat_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of solid to liquid specific heat capacities</p> <p>.. math:: \\lambda = \\frac{c_{p,s}}{c_{p,l}}</p>"},{"location":"#seaice3p.DimensionalWaterParams.stefan_number","title":"<code>stefan_number</code>  <code>property</code>","text":"<p>calculate Stefan number</p> <p>.. math:: \\text{St} = L / c_p \\Delta T</p>"},{"location":"#seaice3p.DimensionalWaterParams.temperature_difference","title":"<code>temperature_difference</code>  <code>property</code>","text":"<p>calculate</p> <p>.. math:: \\Delta T = T_i - T_E</p>"},{"location":"#seaice3p.DimensionalWaterParams.thermal_diffusivity","title":"<code>thermal_diffusivity</code>  <code>property</code>","text":"<p>Return thermal diffusivity in m2/s</p> <p>.. math:: \\kappa = \\frac{k}{\\rho_l c_p}</p>"},{"location":"#seaice3p.EQMPhysicalParams","title":"<code>EQMPhysicalParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BasePhysicalParams</code></p> <p>non dimensional numbers for the mushy layer</p> Source code in <code>seaice3p/params/physical.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass EQMPhysicalParams(BasePhysicalParams):\n    \"\"\"non dimensional numbers for the mushy layer\"\"\"\n</code></pre>"},{"location":"#seaice3p.ERA5Forcing","title":"<code>ERA5Forcing</code>","text":"<p>Forcing parameters for simulation forced with atmospheric variables from reanalysis data in netCDF file located at data_path.</p> <p>Never create this object directly but instead initialise from a dimensional simulation configuration as we must pass it the simulation timescale to correctly read the atmospheric variables from the netCDF file.</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\nclass ERA5Forcing:\n    \"\"\"Forcing parameters for simulation forced with atmospheric variables\n    from reanalysis data in netCDF file located at data_path.\n\n    Never create this object directly but instead initialise from a dimensional\n    simulation configuration as we must pass it the simulation timescale to correctly\n    read the atmospheric variables from the netCDF file.\n    \"\"\"\n\n    data_path: Path\n    start_date: str\n    timescale_in_days: float\n    use_snow_data: bool = False\n    snow_density: Optional[float] = None\n    SW_forcing: DimensionalSWForcing = DimensionalConstantSWForcing()\n    LW_forcing: DimensionalLWForcing = DimensionalConstantLWForcing()\n    turbulent_flux: DimensionalTurbulentFlux = DimensionalConstantTurbulentFlux()\n    oil_heating: DimensionalOilHeating = DimensionalBackgroundOilHeating()\n\n    def __post_init__(self):\n        data = xr.open_dataset(self.data_path)\n        daily_data = data.resample(valid_time=\"1d\").mean()\n        DATES = daily_data.valid_time.to_numpy()\n        DIMLESS_TIMES = (1 / self.timescale_in_days) * np.array(\n            [\n                (date - np.datetime64(self.start_date)) / np.timedelta64(1, \"D\")\n                for date in DATES\n            ]\n        )\n\n        # convert to deg C\n        T2M = daily_data.t2m[:, 0, 0].to_numpy() - 273.15\n        D2M = daily_data.d2m[:, 0, 0].to_numpy() - 273.15\n\n        LW = daily_data.msdwlwrf[:, 0, 0].to_numpy()\n        SW = daily_data.msdwswrf[:, 0, 0].to_numpy()\n\n        # convert to KPa\n        ATM = daily_data.sp[:, 0, 0].to_numpy() / 1e3\n\n        # Calculate specific humidity in kg/kg from dewpoint temperature\n        SPEC_HUM = _calculate_specific_humidity(ATM, D2M)\n\n        # Convert snow depth from m of water equivalent to m of snow\n        if self.use_snow_data:\n            if self.snow_density is None:\n                raise ValueError(\"No snow density provided\")\n            SNOW_DEPTH = daily_data.sd[:, 0, 0].to_numpy() * (1000 / self.snow_density)\n        else:\n            SNOW_DEPTH = np.zeros_like(DIMLESS_TIMES)\n\n        self.get_2m_temp = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=T2M, left=np.nan, right=np.nan\n        )\n        self.get_LW = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=LW, left=np.nan, right=np.nan\n        )\n        self.get_SW = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=SW, left=np.nan, right=np.nan\n        )\n        self.get_ATM = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=ATM, left=np.nan, right=np.nan\n        )\n        self.get_spec_hum = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=SPEC_HUM, left=np.nan, right=np.nan\n        )\n        self.get_snow_depth = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=SNOW_DEPTH, left=np.nan, right=np.nan\n        )\n</code></pre>"},{"location":"#seaice3p.FixedHeatFluxOceanForcing","title":"<code>FixedHeatFluxOceanForcing</code>  <code>dataclass</code>","text":"<p>Provides constant dimensionless ocean heat flux at the bottom of the domain and fixed gas saturation state.</p> Source code in <code>seaice3p/params/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass FixedHeatFluxOceanForcing:\n    \"\"\"Provides constant dimensionless ocean heat flux at the bottom of the domain and fixed gas\n    saturation state.\"\"\"\n\n    ocean_heat_flux: float = 1\n    ocean_gas_sat: float = 1.0\n</code></pre>"},{"location":"#seaice3p.FixedTempOceanForcing","title":"<code>FixedTempOceanForcing</code>  <code>dataclass</code>","text":"<p>Fixed temperature and gas saturation ocean boundary condition</p> Source code in <code>seaice3p/params/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass FixedTempOceanForcing:\n    \"\"\"Fixed temperature and gas saturation ocean boundary condition\"\"\"\n\n    ocean_temp: float = 0.1\n    ocean_gas_sat: float = 1.0\n</code></pre>"},{"location":"#seaice3p.MonoBubbleParams","title":"<code>MonoBubbleParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBubbleParams</code></p> <p>Parameters for population of identical spherical bubbles.</p> Source code in <code>seaice3p/params/bubble.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass MonoBubbleParams(BaseBubbleParams):\n    \"\"\"Parameters for population of identical spherical bubbles.\"\"\"\n\n    bubble_radius_scaled: float = 1.0\n</code></pre>"},{"location":"#seaice3p.NoBrineConvection","title":"<code>NoBrineConvection</code>  <code>dataclass</code>","text":"<p>No brine convection</p> Source code in <code>seaice3p/params/dimensional/convection.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass NoBrineConvection:\n    \"\"\"No brine convection\"\"\"\n</code></pre>"},{"location":"#seaice3p.NumericalParams","title":"<code>NumericalParams</code>  <code>dataclass</code>","text":"<p>parameters needed for discretisation and choice of numerical method</p> Source code in <code>seaice3p/params/dimensional/numerical.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass NumericalParams:\n    \"\"\"parameters needed for discretisation and choice of numerical method\"\"\"\n\n    I: int = 50\n    regularisation: float = 1e-6\n    solver_choice: str = \"RK23\"  # scipy.integrate.solve_IVP solver choice\n\n    @property\n    def step(self):\n        return 1 / self.I\n</code></pre>"},{"location":"#seaice3p.OilInitialConditions","title":"<code>OilInitialConditions</code>  <code>dataclass</code>","text":"<p>values for bottom (ocean) boundary</p> Source code in <code>seaice3p/params/initial_conditions.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass OilInitialConditions:\n    \"\"\"values for bottom (ocean) boundary\"\"\"\n\n    # Non dimensional parameters for summer initial conditions\n    initial_ice_depth: float = 0.5\n    initial_ocean_temperature: float = -0.05\n    initial_ice_temperature: float = -0.1\n    initial_oil_volume_fraction: float = 1e-7\n    initial_ice_bulk_salinity: float = -0.1\n    initial_oil_free_depth: float = 0\n</code></pre>"},{"location":"#seaice3p.PowerLawBubbleParams","title":"<code>PowerLawBubbleParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBubbleParams</code></p> <p>Parameters for population of bubbles following a power law size distribution between a minimum and maximum radius.</p> Source code in <code>seaice3p/params/bubble.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass PowerLawBubbleParams(BaseBubbleParams):\n    \"\"\"Parameters for population of bubbles following a power law size distribution\n    between a minimum and maximum radius.\n    \"\"\"\n\n    bubble_distribution_power: float = 1.5\n    minimum_bubble_radius_scaled: float = 1e-3\n    maximum_bubble_radius_scaled: float = 1\n</code></pre>"},{"location":"#seaice3p.RJW14Params","title":"<code>RJW14Params</code>  <code>dataclass</code>","text":"<p>Parameters for the RJW14 parameterisation of brine convection</p> Source code in <code>seaice3p/params/convection.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass RJW14Params:\n    \"\"\"Parameters for the RJW14 parameterisation of brine convection\"\"\"\n\n    Rayleigh_salt: float = 44105\n    Rayleigh_critical: float = 2.9\n    convection_strength: float = 0.13\n    couple_bubble_to_horizontal_flow: bool = False\n    couple_bubble_to_vertical_flow: bool = False\n    advective_heat_flux_in_ocean: bool = True\n</code></pre>"},{"location":"#seaice3p.RadForcing","title":"<code>RadForcing</code>  <code>dataclass</code>","text":"<p>Forcing parameters for radiative transfer simulation with oil drops</p> <p>we have not implemented the non-dimensionalisation for these parameters yet and so we just pass the dimensional values directly to the simulation</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass RadForcing:\n    \"\"\"Forcing parameters for radiative transfer simulation with oil drops\n\n    we have not implemented the non-dimensionalisation for these parameters yet\n    and so we just pass the dimensional values directly to the simulation\"\"\"\n\n    SW_forcing: DimensionalSWForcing = DimensionalConstantSWForcing()\n    LW_forcing: DimensionalLWForcing = DimensionalConstantLWForcing()\n    turbulent_flux: DimensionalTurbulentFlux = DimensionalConstantTurbulentFlux()\n    oil_heating: DimensionalOilHeating = DimensionalBackgroundOilHeating()\n</code></pre>"},{"location":"#seaice3p.RobinForcing","title":"<code>RobinForcing</code>  <code>dataclass</code>","text":"<p>Dimensionless forcing parameters for Robin boundary condition</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass RobinForcing:\n    \"\"\"Dimensionless forcing parameters for Robin boundary condition\"\"\"\n\n    biot: float = 12\n    restoring_temperature: float = -1.3\n</code></pre>"},{"location":"#seaice3p.Scales","title":"<code>Scales</code>  <code>dataclass</code>","text":"Source code in <code>seaice3p/params/convert.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass Scales:\n    lengthscale: float  # domain height in m\n    thermal_diffusivity: float  # m2/s\n    liquid_thermal_conductivity: float  # W/m deg C\n    ocean_salinity: float  # g/kg\n    salinity_difference: float  # g/kg\n    ocean_freezing_temperature: float  # deg C\n    temperature_difference: float  # deg C\n    gas_density: float  # kg/m3\n    liquid_density: float  # kg/m3\n    ice_density: float  # kg/m3\n    saturation_concentration: float  # kg(gas)/kg(liquid)\n    pore_radius: float  # m\n    haline_contraction_coefficient: float  # 1/ppt\n\n    @property\n    def time_scale(self):\n        \"\"\"in days\"\"\"\n        return SECONDS_TO_DAYS * self.lengthscale**2 / self.thermal_diffusivity\n\n    @property\n    def velocity_scale(self):\n        \"\"\"in m /day\"\"\"\n        return self.lengthscale / self.time_scale\n\n    def convert_from_dimensional_temperature(self, dimensional_temperature):\n        \"\"\"Non dimensionalise temperature in deg C\"\"\"\n        return (\n            dimensional_temperature - self.ocean_freezing_temperature\n        ) / self.temperature_difference\n\n    def convert_to_dimensional_temperature(self, temperature):\n        \"\"\"get temperature in deg C from non dimensional temperature\"\"\"\n        return (\n            self.temperature_difference * temperature + self.ocean_freezing_temperature\n        )\n\n    def convert_from_dimensional_grid(self, dimensional_grid):\n        \"\"\"Non dimensionalise domain depths in meters\"\"\"\n        return dimensional_grid / self.lengthscale\n\n    def convert_to_dimensional_grid(self, grid):\n        \"\"\"Get domain depths in meters from non dimensional values\"\"\"\n        return self.lengthscale * grid\n\n    def convert_from_dimensional_time(self, dimensional_time):\n        \"\"\"Non dimensionalise time in days\"\"\"\n        return dimensional_time / self.time_scale\n\n    def convert_to_dimensional_time(self, time):\n        \"\"\"Convert non dimensional time into time in days since start of simulation\"\"\"\n        return self.time_scale * time\n\n    def convert_from_dimensional_bulk_salinity(self, dimensional_bulk_salinity):\n        \"\"\"Non dimensionalise bulk salinity in g/kg\"\"\"\n        return (\n            dimensional_bulk_salinity - self.ocean_salinity\n        ) / self.salinity_difference\n\n    def convert_to_dimensional_bulk_salinity(self, bulk_salinity):\n        \"\"\"Convert non dimensional bulk salinity to g/kg\"\"\"\n        return self.salinity_difference * bulk_salinity + self.ocean_salinity\n\n    def convert_from_dimensional_bulk_gas(self, dimensional_bulk_gas):\n        \"\"\"Non dimensionalise bulk gas content in kg/m3\"\"\"\n        return dimensional_bulk_gas / self.gas_density\n\n    def convert_to_dimensional_bulk_gas(self, bulk_gas):\n        \"\"\"Convert dimensionless bulk gas content to kg/m3\"\"\"\n        return self.gas_density * bulk_gas\n\n    def convert_dimensional_bulk_air_to_argon_content(self, dimensional_bulk_gas):\n        \"\"\"Convert kg/m3 of air to micromole of Argon per Liter of ice\"\"\"\n        mass_ratio_of_argon_in_air = 0.01288\n        micromoles_of_argon_in_a_kilogram_of_argon = 1 / (3.9948e-8)\n        liters_in_a_meter_cubed = 1e3\n        return (\n            dimensional_bulk_gas\n            * mass_ratio_of_argon_in_air\n            * micromoles_of_argon_in_a_kilogram_of_argon\n            / liters_in_a_meter_cubed\n        )\n\n    def convert_from_dimensional_dissolved_gas(self, dimensional_dissolved_gas):\n        \"\"\"convert from dissolved gas in kg(gas)/kg(liquid) to dimensionless\"\"\"\n        return dimensional_dissolved_gas / self.saturation_concentration\n\n    def convert_to_dimensional_dissolved_gas(self, dissolved_gas):\n        \"\"\"convert from non dimensional dissolved gas to dimensional dissolved gas in\n        kg(gas)/kg(liquid)\"\"\"\n        return self.saturation_concentration * dissolved_gas\n\n    def convert_from_dimensional_heating(self, dimensional_heating):\n        \"\"\"convert from heating rate in W/m3 to dimensionless units\"\"\"\n        return (\n            dimensional_heating\n            * self.lengthscale**2\n            / (self.liquid_thermal_conductivity * self.temperature_difference)\n        )\n\n    def convert_from_dimensional_heat_flux(self, dimensional_heat_flux):\n        \"\"\"convert from heat flux in W/m2 to dimensionless units\"\"\"\n        return (\n            dimensional_heat_flux\n            * self.lengthscale\n            / (self.liquid_thermal_conductivity * self.temperature_difference)\n        )\n\n    def convert_to_dimensional_heat_flux(self, heat_flux):\n        \"\"\"convert from dimensionless heat flux to heat flux in W/m2\"\"\"\n        return (\n            heat_flux\n            * (self.liquid_thermal_conductivity * self.temperature_difference)\n            / self.lengthscale\n        )\n</code></pre>"},{"location":"#seaice3p.Scales.time_scale","title":"<code>time_scale</code>  <code>property</code>","text":"<p>in days</p>"},{"location":"#seaice3p.Scales.velocity_scale","title":"<code>velocity_scale</code>  <code>property</code>","text":"<p>in m /day</p>"},{"location":"#seaice3p.Scales.convert_dimensional_bulk_air_to_argon_content","title":"<code>convert_dimensional_bulk_air_to_argon_content(dimensional_bulk_gas)</code>","text":"<p>Convert kg/m3 of air to micromole of Argon per Liter of ice</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_dimensional_bulk_air_to_argon_content(self, dimensional_bulk_gas):\n    \"\"\"Convert kg/m3 of air to micromole of Argon per Liter of ice\"\"\"\n    mass_ratio_of_argon_in_air = 0.01288\n    micromoles_of_argon_in_a_kilogram_of_argon = 1 / (3.9948e-8)\n    liters_in_a_meter_cubed = 1e3\n    return (\n        dimensional_bulk_gas\n        * mass_ratio_of_argon_in_air\n        * micromoles_of_argon_in_a_kilogram_of_argon\n        / liters_in_a_meter_cubed\n    )\n</code></pre>"},{"location":"#seaice3p.Scales.convert_from_dimensional_bulk_gas","title":"<code>convert_from_dimensional_bulk_gas(dimensional_bulk_gas)</code>","text":"<p>Non dimensionalise bulk gas content in kg/m3</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_bulk_gas(self, dimensional_bulk_gas):\n    \"\"\"Non dimensionalise bulk gas content in kg/m3\"\"\"\n    return dimensional_bulk_gas / self.gas_density\n</code></pre>"},{"location":"#seaice3p.Scales.convert_from_dimensional_bulk_salinity","title":"<code>convert_from_dimensional_bulk_salinity(dimensional_bulk_salinity)</code>","text":"<p>Non dimensionalise bulk salinity in g/kg</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_bulk_salinity(self, dimensional_bulk_salinity):\n    \"\"\"Non dimensionalise bulk salinity in g/kg\"\"\"\n    return (\n        dimensional_bulk_salinity - self.ocean_salinity\n    ) / self.salinity_difference\n</code></pre>"},{"location":"#seaice3p.Scales.convert_from_dimensional_dissolved_gas","title":"<code>convert_from_dimensional_dissolved_gas(dimensional_dissolved_gas)</code>","text":"<p>convert from dissolved gas in kg(gas)/kg(liquid) to dimensionless</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_dissolved_gas(self, dimensional_dissolved_gas):\n    \"\"\"convert from dissolved gas in kg(gas)/kg(liquid) to dimensionless\"\"\"\n    return dimensional_dissolved_gas / self.saturation_concentration\n</code></pre>"},{"location":"#seaice3p.Scales.convert_from_dimensional_grid","title":"<code>convert_from_dimensional_grid(dimensional_grid)</code>","text":"<p>Non dimensionalise domain depths in meters</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_grid(self, dimensional_grid):\n    \"\"\"Non dimensionalise domain depths in meters\"\"\"\n    return dimensional_grid / self.lengthscale\n</code></pre>"},{"location":"#seaice3p.Scales.convert_from_dimensional_heat_flux","title":"<code>convert_from_dimensional_heat_flux(dimensional_heat_flux)</code>","text":"<p>convert from heat flux in W/m2 to dimensionless units</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_heat_flux(self, dimensional_heat_flux):\n    \"\"\"convert from heat flux in W/m2 to dimensionless units\"\"\"\n    return (\n        dimensional_heat_flux\n        * self.lengthscale\n        / (self.liquid_thermal_conductivity * self.temperature_difference)\n    )\n</code></pre>"},{"location":"#seaice3p.Scales.convert_from_dimensional_heating","title":"<code>convert_from_dimensional_heating(dimensional_heating)</code>","text":"<p>convert from heating rate in W/m3 to dimensionless units</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_heating(self, dimensional_heating):\n    \"\"\"convert from heating rate in W/m3 to dimensionless units\"\"\"\n    return (\n        dimensional_heating\n        * self.lengthscale**2\n        / (self.liquid_thermal_conductivity * self.temperature_difference)\n    )\n</code></pre>"},{"location":"#seaice3p.Scales.convert_from_dimensional_temperature","title":"<code>convert_from_dimensional_temperature(dimensional_temperature)</code>","text":"<p>Non dimensionalise temperature in deg C</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_temperature(self, dimensional_temperature):\n    \"\"\"Non dimensionalise temperature in deg C\"\"\"\n    return (\n        dimensional_temperature - self.ocean_freezing_temperature\n    ) / self.temperature_difference\n</code></pre>"},{"location":"#seaice3p.Scales.convert_from_dimensional_time","title":"<code>convert_from_dimensional_time(dimensional_time)</code>","text":"<p>Non dimensionalise time in days</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_time(self, dimensional_time):\n    \"\"\"Non dimensionalise time in days\"\"\"\n    return dimensional_time / self.time_scale\n</code></pre>"},{"location":"#seaice3p.Scales.convert_to_dimensional_bulk_gas","title":"<code>convert_to_dimensional_bulk_gas(bulk_gas)</code>","text":"<p>Convert dimensionless bulk gas content to kg/m3</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_bulk_gas(self, bulk_gas):\n    \"\"\"Convert dimensionless bulk gas content to kg/m3\"\"\"\n    return self.gas_density * bulk_gas\n</code></pre>"},{"location":"#seaice3p.Scales.convert_to_dimensional_bulk_salinity","title":"<code>convert_to_dimensional_bulk_salinity(bulk_salinity)</code>","text":"<p>Convert non dimensional bulk salinity to g/kg</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_bulk_salinity(self, bulk_salinity):\n    \"\"\"Convert non dimensional bulk salinity to g/kg\"\"\"\n    return self.salinity_difference * bulk_salinity + self.ocean_salinity\n</code></pre>"},{"location":"#seaice3p.Scales.convert_to_dimensional_dissolved_gas","title":"<code>convert_to_dimensional_dissolved_gas(dissolved_gas)</code>","text":"<p>convert from non dimensional dissolved gas to dimensional dissolved gas in kg(gas)/kg(liquid)</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_dissolved_gas(self, dissolved_gas):\n    \"\"\"convert from non dimensional dissolved gas to dimensional dissolved gas in\n    kg(gas)/kg(liquid)\"\"\"\n    return self.saturation_concentration * dissolved_gas\n</code></pre>"},{"location":"#seaice3p.Scales.convert_to_dimensional_grid","title":"<code>convert_to_dimensional_grid(grid)</code>","text":"<p>Get domain depths in meters from non dimensional values</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_grid(self, grid):\n    \"\"\"Get domain depths in meters from non dimensional values\"\"\"\n    return self.lengthscale * grid\n</code></pre>"},{"location":"#seaice3p.Scales.convert_to_dimensional_heat_flux","title":"<code>convert_to_dimensional_heat_flux(heat_flux)</code>","text":"<p>convert from dimensionless heat flux to heat flux in W/m2</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_heat_flux(self, heat_flux):\n    \"\"\"convert from dimensionless heat flux to heat flux in W/m2\"\"\"\n    return (\n        heat_flux\n        * (self.liquid_thermal_conductivity * self.temperature_difference)\n        / self.lengthscale\n    )\n</code></pre>"},{"location":"#seaice3p.Scales.convert_to_dimensional_temperature","title":"<code>convert_to_dimensional_temperature(temperature)</code>","text":"<p>get temperature in deg C from non dimensional temperature</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_temperature(self, temperature):\n    \"\"\"get temperature in deg C from non dimensional temperature\"\"\"\n    return (\n        self.temperature_difference * temperature + self.ocean_freezing_temperature\n    )\n</code></pre>"},{"location":"#seaice3p.Scales.convert_to_dimensional_time","title":"<code>convert_to_dimensional_time(time)</code>","text":"<p>Convert non dimensional time into time in days since start of simulation</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_time(self, time):\n    \"\"\"Convert non dimensional time into time in days since start of simulation\"\"\"\n    return self.time_scale * time\n</code></pre>"},{"location":"#seaice3p.UniformInitialConditions","title":"<code>UniformInitialConditions</code>  <code>dataclass</code>","text":"<p>values for bottom (ocean) boundary</p> Source code in <code>seaice3p/params/dimensional/initial_conditions.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass UniformInitialConditions:\n    \"\"\"values for bottom (ocean) boundary\"\"\"\n</code></pre>"},{"location":"#seaice3p.YearlyForcing","title":"<code>YearlyForcing</code>  <code>dataclass</code>","text":"<p>Yearly sinusoidal temperature forcing</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass YearlyForcing:\n    \"\"\"Yearly sinusoidal temperature forcing\"\"\"\n\n    offset: float = -1.0\n    amplitude: float = 0.75\n    period: float = 4.0\n</code></pre>"},{"location":"#seaice3p.get_config","title":"<code>get_config(dimensional_params)</code>","text":"<p>Return a Config object for the simulation.</p> <p>physical parameters and Darcy law parameters are calculated from the dimensional input. You can modify the numerical parameters and boundary conditions and forcing provided for the simulation.</p> Source code in <code>seaice3p/params/params.py</code> <pre><code>def get_config(dimensional_params: DimensionalParams) -&gt; Config:\n    \"\"\"Return a Config object for the simulation.\n\n    physical parameters and Darcy law parameters are calculated from the dimensional\n    input. You can modify the numerical parameters and boundary conditions and\n    forcing provided for the simulation.\"\"\"\n    physical_params = get_dimensionless_physical_params(dimensional_params)\n    initial_conditions_config = get_dimensionless_initial_conditions_config(\n        dimensional_params\n    )\n    brine_convection_params = get_dimensionless_brine_convection_params(\n        dimensional_params\n    )\n    bubble_params = get_dimensionless_bubble_params(dimensional_params)\n    forcing_config = get_dimensionless_forcing_config(dimensional_params)\n    ocean_forcing_config = get_dimensionless_ocean_forcing_config(dimensional_params)\n    return Config(\n        name=dimensional_params.name,\n        physical_params=physical_params,\n        initial_conditions_config=initial_conditions_config,\n        brine_convection_params=brine_convection_params,\n        bubble_params=bubble_params,\n        forcing_config=forcing_config,\n        ocean_forcing_config=ocean_forcing_config,\n        numerical_params=dimensional_params.numerical_params,\n        scales=dimensional_params.scales,\n        total_time=dimensional_params.total_time,\n        savefreq=dimensional_params.savefreq,\n    )\n</code></pre>"},{"location":"#seaice3p.enthalpy_method","title":"<code>enthalpy_method</code>","text":""},{"location":"#seaice3p.enthalpy_method.enthalpy_method","title":"<code>enthalpy_method</code>","text":"<p>Module containing enthalpy method to calculate state variables from bulk enthalpy, bulk salinity and bulk gas.</p>"},{"location":"#seaice3p.enthalpy_method.phase_boundaries","title":"<code>phase_boundaries</code>","text":"<p>Module for calculating the phase boundaries needed for the enthalpy method.</p> <p>calculates the phase boundaries neglecting the gas fraction so that</p> <pre><code>.. math:: \\phi_s + \\phi_l = 1\n</code></pre>"},{"location":"#seaice3p.equations","title":"<code>equations</code>","text":""},{"location":"#seaice3p.equations.RJW14","title":"<code>RJW14</code>","text":"<p>Module to calculate the sink terms for conservation equations when using the Rees Jones and Worster 2014 brine drainage parameterisation.</p> <p>These terms represent loss through the brine channels and need to be added in the convecting region when using this parameterisation</p>"},{"location":"#seaice3p.equations.RJW14.brine_channel_sink_terms","title":"<code>brine_channel_sink_terms</code>","text":""},{"location":"#seaice3p.equations.RJW14.brine_drainage","title":"<code>brine_drainage</code>","text":"<p>Module to calculate the Rees Jones and Worster 2014 parameterisation for brine convection velocity and the strenght of the sink term.</p> <p>Exports the functions:</p> <p>calculate_brine_convection_liquid_velocity To be used in velocities module when using brine convection parameterisation.</p> <p>calculate_brine_channel_sink To be used to add sink terms to conservation equations when using brine convection parameterisation.</p>"},{"location":"#seaice3p.equations.RJW14.brine_drainage.calculate_Rayleigh","title":"<code>calculate_Rayleigh(cell_centers, edge_grid, liquid_salinity, liquid_fraction, cfg)</code>","text":"<p>Calculate the local Rayleigh number for brine convection as</p> <p>.. math:: \\text{Ra}(z) = \\text{Ra}_S K(z) (z+h) \\Theta_l</p> <p>:param cell_centers: The vertical coordinates of cell centers. :type cell_centers: Numpy Array shape (I,) :param edge_grid: The vertical coordinate positions of the edge grid. :type edge_grid: Numpy Array (size I+1) :param liquid_salinity: liquid salinity on center grid :type liquid_salinity: Numpy Array shape (I,) :param liquid_fraction: liquid fraction on center grid :type liquid_fraction: Numpy Array (size I) :param cfg: Configuration object for the simulation. :type cfg: seaice3p.params.Config :return: Array of shape (I,) of Rayleigh number at cell centers</p> Source code in <code>seaice3p/equations/RJW14/brine_drainage.py</code> <pre><code>def calculate_Rayleigh(\n    cell_centers, edge_grid, liquid_salinity, liquid_fraction, cfg: Config\n):\n    r\"\"\"Calculate the local Rayleigh number for brine convection as\n\n    .. math:: \\text{Ra}(z) = \\text{Ra}_S K(z) (z+h) \\Theta_l\n\n    :param cell_centers: The vertical coordinates of cell centers.\n    :type cell_centers: Numpy Array shape (I,)\n    :param edge_grid: The vertical coordinate positions of the edge grid.\n    :type edge_grid: Numpy Array (size I+1)\n    :param liquid_salinity: liquid salinity on center grid\n    :type liquid_salinity: Numpy Array shape (I,)\n    :param liquid_fraction: liquid fraction on center grid\n    :type liquid_fraction: Numpy Array (size I)\n    :param cfg: Configuration object for the simulation.\n    :type cfg: seaice3p.params.Config\n    :return: Array of shape (I,) of Rayleigh number at cell centers\n    \"\"\"\n    Rayleigh_salt = cfg.brine_convection_params.Rayleigh_salt\n    ice_depth = calculate_ice_ocean_boundary_depth(liquid_fraction, edge_grid)\n    averaged_permeabilities = np.array(\n        [\n            calculate_integrated_mean_permeability(\n                z=z,\n                liquid_fraction=liquid_fraction,\n                ice_depth=ice_depth,\n                cell_centers=cell_centers,\n                cfg=cfg,\n            )\n            for z in cell_centers\n        ]\n    )\n    return (\n        Rayleigh_salt\n        * (ice_depth + cell_centers)\n        * averaged_permeabilities\n        * liquid_salinity\n    )\n</code></pre>"},{"location":"#seaice3p.equations.RJW14.brine_drainage.calculate_brine_channel_sink","title":"<code>calculate_brine_channel_sink(liquid_fraction, liquid_salinity, center_grid, edge_grid, cfg)</code>","text":"<p>Calculate the sink term due to brine channels.</p> <p>.. math:: \\text{sink} = \\mathcal{A}</p> <p>in the convecting region. Zero elsewhere.</p> <p>NOTE: If no ice is present or if no convecting region exists returns zero</p> <p>:param liquid_fraction: liquid fraction on center grid :type liquid_fraction: Numpy Array of shape (I,) :param liquid_salinity: liquid salinity on center grid :type liquid_salinity: Numpy Array of shape (I,) :param center_grid: vertical coordinate of center grid :type center_grid: Numpy Array of shape (I,) :param edge_grid: Vertical coordinates of cell edges :type edge_grid: Numpy Array of shape (I+1,) :param cfg: Configuration object for the simulation. :type cfg: seaice3p.params.Config :return: Strength of the sink term due to brine channels on the center grid.</p> Source code in <code>seaice3p/equations/RJW14/brine_drainage.py</code> <pre><code>def calculate_brine_channel_sink(\n    liquid_fraction, liquid_salinity, center_grid, edge_grid, cfg: Config\n):\n    r\"\"\"Calculate the sink term due to brine channels.\n\n    .. math:: \\text{sink} = \\mathcal{A}\n\n    in the convecting region. Zero elsewhere.\n\n    NOTE: If no ice is present or if no convecting region exists returns zero\n\n    :param liquid_fraction: liquid fraction on center grid\n    :type liquid_fraction: Numpy Array of shape (I,)\n    :param liquid_salinity: liquid salinity on center grid\n    :type liquid_salinity: Numpy Array of shape (I,)\n    :param center_grid: vertical coordinate of center grid\n    :type center_grid: Numpy Array of shape (I,)\n    :param edge_grid: Vertical coordinates of cell edges\n    :type edge_grid: Numpy Array of shape (I+1,)\n    :param cfg: Configuration object for the simulation.\n    :type cfg: seaice3p.params.Config\n    :return: Strength of the sink term due to brine channels on the center grid.\n    \"\"\"\n    ice_depth = calculate_ice_ocean_boundary_depth(liquid_fraction, edge_grid)\n    Rayleigh_number = calculate_Rayleigh(\n        center_grid, edge_grid, liquid_salinity, liquid_fraction, cfg\n    )\n    convecting_region_height = get_convecting_region_height(\n        Rayleigh_number, edge_grid, cfg\n    )\n    brine_channel_strength = calculate_brine_channel_strength(\n        Rayleigh_number, ice_depth, convecting_region_height, cfg\n    )\n\n    sink = np.zeros_like(center_grid)\n\n    # No ice present\n    if ice_depth == 0:\n        return sink\n\n    # ice present but no convection occuring\n    if np.isnan(convecting_region_height):\n        return sink\n\n    # Make liquid vertical velocity continuous at bottom of the ice\n\n    is_convecting_ice = (center_grid &gt;= -ice_depth) &amp; (\n        center_grid &lt;= convecting_region_height\n    )\n    is_liquid = center_grid &lt; -ice_depth\n\n    sink[is_convecting_ice] = brine_channel_strength\n    sink[is_liquid] = 0\n\n    return sink\n</code></pre>"},{"location":"#seaice3p.equations.RJW14.brine_drainage.calculate_brine_channel_strength","title":"<code>calculate_brine_channel_strength(Rayleigh_number, ice_depth, convecting_region_height, cfg)</code>","text":"<p>Calculate the brine channel strength in the convecting region as</p> <p>.. math:: \\mathcal{A} = \\frac{\\alpha \\text{Ra}_e}{(h+z_c)^2}</p> <p>the effective Rayleigh number multiplied by a tuning parameter (Rees Jones and Worster 2014) over the convecting region thickness squared.</p> <p>:param Rayleigh_number: local Rayleigh number on center grid :type Rayleigh_number: Numpy Array of shape (I,) :param ice_depth: depth of ice (positive) :type ice_depth: float :param convecting_region_height: position of the convecting region boundary (negative) :type convecting_region_height: float :param cfg: Configuration object for the simulation. :type cfg: seaice3p.params.Config :return: Brine channel strength parameter</p> Source code in <code>seaice3p/equations/RJW14/brine_drainage.py</code> <pre><code>def calculate_brine_channel_strength(\n    Rayleigh_number, ice_depth, convecting_region_height, cfg: Config\n):\n    r\"\"\"Calculate the brine channel strength in the convecting region as\n\n    .. math:: \\mathcal{A} = \\frac{\\alpha \\text{Ra}_e}{(h+z_c)^2}\n\n    the effective Rayleigh number multiplied by a tuning parameter (Rees Jones and\n    Worster 2014) over the convecting region thickness squared.\n\n    :param Rayleigh_number: local Rayleigh number on center grid\n    :type Rayleigh_number: Numpy Array of shape (I,)\n    :param ice_depth: depth of ice (positive)\n    :type ice_depth: float\n    :param convecting_region_height: position of the convecting region boundary (negative)\n    :type convecting_region_height: float\n    :param cfg: Configuration object for the simulation.\n    :type cfg: seaice3p.params.Config\n    :return: Brine channel strength parameter\n    \"\"\"\n    convection_strength = cfg.brine_convection_params.convection_strength\n    if ice_depth == 0:\n        return 0\n\n    if np.isnan(convecting_region_height):\n        return 0\n\n    convecting_layer_thickness = ice_depth + convecting_region_height\n    effective_Rayleigh = get_effective_Rayleigh_number(Rayleigh_number, cfg)\n    return convection_strength * effective_Rayleigh / convecting_layer_thickness**2\n</code></pre>"},{"location":"#seaice3p.equations.RJW14.brine_drainage.calculate_brine_convection_liquid_velocity","title":"<code>calculate_brine_convection_liquid_velocity(liquid_fraction, liquid_salinity, center_grid, edge_grid, cfg)</code>","text":"<p>Calculate the vertical liquid Darcy velocity from Rees Jones and Worster 2014</p> <p>.. math:: W_l = \\mathcal{A} (z_c - z)</p> <p>in the convecting region. The velocity is stagnant above the convecting region. The velocity is constant in the liquid region and continuous at the interface.</p> <p>NOTE: If no ice is present or if no convecting region exists returns zero velocity</p> <p>:param liquid_fraction: liquid fraction on center grid :type liquid_fraction: Numpy Array of shape (I,) :param liquid_salinity: liquid salinity on center grid :type liquid_salinity: Numpy Array of shape (I,) :param center_grid: vertical coordinate of center grid :type center_grid: Numpy Array of shape (I,) :param edge_grid: Vertical coordinates of cell edges :type edge_grid: Numpy Array of shape (I+1,) :param cfg: Configuration object for the simulation. :type cfg: seaice3p.params.Config :return: Liquid darcy velocity on the edge grid.</p> Source code in <code>seaice3p/equations/RJW14/brine_drainage.py</code> <pre><code>def calculate_brine_convection_liquid_velocity(\n    liquid_fraction, liquid_salinity, center_grid, edge_grid, cfg: Config\n):\n    r\"\"\"Calculate the vertical liquid Darcy velocity from Rees Jones and Worster 2014\n\n    .. math:: W_l = \\mathcal{A} (z_c - z)\n\n    in the convecting region. The velocity is stagnant above the convecting region.\n    The velocity is constant in the liquid region and continuous at the interface.\n\n    NOTE: If no ice is present or if no convecting region exists returns zero velocity\n\n    :param liquid_fraction: liquid fraction on center grid\n    :type liquid_fraction: Numpy Array of shape (I,)\n    :param liquid_salinity: liquid salinity on center grid\n    :type liquid_salinity: Numpy Array of shape (I,)\n    :param center_grid: vertical coordinate of center grid\n    :type center_grid: Numpy Array of shape (I,)\n    :param edge_grid: Vertical coordinates of cell edges\n    :type edge_grid: Numpy Array of shape (I+1,)\n    :param cfg: Configuration object for the simulation.\n    :type cfg: seaice3p.params.Config\n    :return: Liquid darcy velocity on the edge grid.\n    \"\"\"\n    ice_depth = calculate_ice_ocean_boundary_depth(liquid_fraction, edge_grid)\n    Rayleigh_number = calculate_Rayleigh(\n        center_grid, edge_grid, liquid_salinity, liquid_fraction, cfg\n    )\n    convecting_region_height = get_convecting_region_height(\n        Rayleigh_number, edge_grid, cfg\n    )\n    brine_channel_strength = calculate_brine_channel_strength(\n        Rayleigh_number, ice_depth, convecting_region_height, cfg\n    )\n\n    Wl = np.zeros_like(edge_grid)\n\n    # No ice present\n    if ice_depth == 0:\n        return Wl\n\n    # ice present but no convection occuring\n    if np.isnan(convecting_region_height):\n        return Wl\n\n    # Make liquid vertical velocity continuous at bottom of the ice\n    ocean_velocity = brine_channel_strength * (ice_depth + convecting_region_height)\n\n    is_convecting_ice = (edge_grid &gt;= -ice_depth) &amp; (\n        edge_grid &lt;= convecting_region_height\n    )\n    is_liquid = edge_grid &lt; -ice_depth\n\n    Wl[is_convecting_ice] = brine_channel_strength * (\n        convecting_region_height - edge_grid[is_convecting_ice]\n    )\n    Wl[is_liquid] = ocean_velocity\n\n    return Wl\n</code></pre>"},{"location":"#seaice3p.equations.RJW14.brine_drainage.calculate_integrated_mean_permeability","title":"<code>calculate_integrated_mean_permeability(z, liquid_fraction, ice_depth, cell_centers, cfg)</code>","text":"<p>Calculate the harmonic mean permeability from the base of the ice up to the cell containing the specified z value using the expression of ReesJones2014.</p> <p>.. math:: K(z) = (\\frac{1}{h+z}\\int_{-h}^{z} \\frac{1}{\\Pi(\\phi_l(z'))}dz')^{-1}</p> <p>:param z: height to integrate permeability up to :type z: float :param liquid_fraction: liquid fraction on the center grid :type liquid_fraction: Numpy Array shape (I,) :param ice_depth: positive depth position of ice ocean interface :type ice_depth: float :param cell_centers: cell center positions :type cell_centers: Numpy Array of shape (I,) :param cfg: Configuration object for the simulation. :type cfg: seaice3p.params.Config :return: permeability averaged from base of the ice up to given z value</p> Source code in <code>seaice3p/equations/RJW14/brine_drainage.py</code> <pre><code>def calculate_integrated_mean_permeability(\n    z, liquid_fraction, ice_depth, cell_centers, cfg: Config\n):\n    r\"\"\"Calculate the harmonic mean permeability from the base of the ice up to the\n    cell containing the specified z value using the expression of ReesJones2014.\n\n    .. math:: K(z) = (\\frac{1}{h+z}\\int_{-h}^{z} \\frac{1}{\\Pi(\\phi_l(z'))}dz')^{-1}\n\n    :param z: height to integrate permeability up to\n    :type z: float\n    :param liquid_fraction: liquid fraction on the center grid\n    :type liquid_fraction: Numpy Array shape (I,)\n    :param ice_depth: positive depth position of ice ocean interface\n    :type ice_depth: float\n    :param cell_centers: cell center positions\n    :type cell_centers: Numpy Array of shape (I,)\n    :param cfg: Configuration object for the simulation.\n    :type cfg: seaice3p.params.Config\n    :return: permeability averaged from base of the ice up to given z value\n    \"\"\"\n    if z &lt; -ice_depth:\n        return 0\n    step = cfg.numerical_params.step\n    ice_mask = (cell_centers &gt; -ice_depth) &amp; (cell_centers &lt;= z)\n    permeabilities = (\n        calculate_permeability(liquid_fraction[ice_mask], cfg)\n        / liquid_fraction[ice_mask].size\n    )\n    harmonic_mean = hmean(permeabilities)\n    return (ice_depth + z + step / 2) * harmonic_mean / step\n</code></pre>"},{"location":"#seaice3p.equations.RJW14.brine_drainage.calculate_permeability","title":"<code>calculate_permeability(liquid_fraction, cfg)</code>","text":"<p>Calculate the absolute permeability as a function of liquid fraction</p> <p>.. math:: \\Pi(\\phi_l) = \\phi_l^3</p> <p>Alternatively if the porosity threshold flag is true</p> <p>.. math:: \\Pi(\\phi_l) = \\phi_l^2 (\\phi_l - \\phi_c)</p> <p>:param liquid_fraction: liquid fraction :type liquid_fraction: Numpy Array :param cfg: Configuration object for the simulation. :type cfg: seaice3p.params.Config :return: permeability on the same grid as liquid fraction</p> Source code in <code>seaice3p/equations/RJW14/brine_drainage.py</code> <pre><code>def calculate_permeability(liquid_fraction, cfg: Config):\n    r\"\"\"Calculate the absolute permeability as a function of liquid fraction\n\n    .. math:: \\Pi(\\phi_l) = \\phi_l^3\n\n    Alternatively if the porosity threshold flag is true\n\n    .. math:: \\Pi(\\phi_l) = \\phi_l^2 (\\phi_l - \\phi_c)\n\n    :param liquid_fraction: liquid fraction\n    :type liquid_fraction: Numpy Array\n    :param cfg: Configuration object for the simulation.\n    :type cfg: seaice3p.params.Config\n    :return: permeability on the same grid as liquid fraction\n    \"\"\"\n    if cfg.bubble_params.porosity_threshold:\n        cutoff = cfg.bubble_params.porosity_threshold_value\n        step_function = np.heaviside(liquid_fraction - cutoff, 0)\n        return liquid_fraction**2 * (liquid_fraction - cutoff) * step_function\n    return liquid_fraction**3\n</code></pre>"},{"location":"#seaice3p.equations.RJW14.brine_drainage.get_convecting_region_height","title":"<code>get_convecting_region_height(Rayleigh_number, edge_grid, cfg)</code>","text":"<p>Calculate the height of the convecting region as the top edge of the highest cell in the domain for which the quantity</p> <p>.. math:: \\text{Ra}(z) - \\text{Ra}_c</p> <p>is greater than or equal to zero.</p> <p>NOTE: if no convecting region exists return np.nan</p> <p>:param Rayleigh_number: local rayleigh number on center grid :type Rayleigh_number: Numpy Array of shape (I,) :param edge_grid: The vertical coordinate positions of the edge grid. :type edge_grid: Numpy Array (size I+1) :param cfg: Configuration object for the simulation. :type cfg: seaice3p.params.Config :return: Edge grid value at convecting boundary.</p> Source code in <code>seaice3p/equations/RJW14/brine_drainage.py</code> <pre><code>def get_convecting_region_height(Rayleigh_number, edge_grid, cfg: Config):\n    r\"\"\"Calculate the height of the convecting region as the top edge of the highest\n    cell in the domain for which the quantity\n\n    .. math:: \\text{Ra}(z) - \\text{Ra}_c\n\n    is greater than or equal to zero.\n\n    NOTE: if no convecting region exists return np.nan\n\n    :param Rayleigh_number: local rayleigh number on center grid\n    :type Rayleigh_number: Numpy Array of shape (I,)\n    :param edge_grid: The vertical coordinate positions of the edge grid.\n    :type edge_grid: Numpy Array (size I+1)\n    :param cfg: Configuration object for the simulation.\n    :type cfg: seaice3p.params.Config\n    :return: Edge grid value at convecting boundary.\n    \"\"\"\n    Rayleigh_critical = cfg.brine_convection_params.Rayleigh_critical\n    if np.all(Rayleigh_number - Rayleigh_critical &lt; 0):\n        return np.nan\n    indices = np.where(Rayleigh_number &gt;= Rayleigh_critical)\n    return edge_grid[indices[0][-1] + 1]\n</code></pre>"},{"location":"#seaice3p.equations.RJW14.brine_drainage.get_effective_Rayleigh_number","title":"<code>get_effective_Rayleigh_number(Rayleigh_number, cfg)</code>","text":"<p>Calculate the effective Rayleigh Number as the maximum of</p> <p>.. math:: \\text{Ra}(z) - \\text{Ra}_c</p> <p>in the convecting region.</p> <p>NOTE: if no convecting region exists returns 0.</p> <p>:param Rayleigh_number: local rayleigh number on center grid :type Rayleigh_number: Numpy Array of shape (I,) :param cfg: Configuration object for the simulation. :type cfg: seaice3p.params.Config :return: Effective Rayleigh number.</p> Source code in <code>seaice3p/equations/RJW14/brine_drainage.py</code> <pre><code>def get_effective_Rayleigh_number(Rayleigh_number, cfg: Config):\n    r\"\"\"Calculate the effective Rayleigh Number as the maximum of\n\n    .. math:: \\text{Ra}(z) - \\text{Ra}_c\n\n    in the convecting region.\n\n    NOTE: if no convecting region exists returns 0.\n\n    :param Rayleigh_number: local rayleigh number on center grid\n    :type Rayleigh_number: Numpy Array of shape (I,)\n    :param cfg: Configuration object for the simulation.\n    :type cfg: seaice3p.params.Config\n    :return: Effective Rayleigh number.\n    \"\"\"\n    Rayleigh_critical = cfg.brine_convection_params.Rayleigh_critical\n    return np.max(\n        np.where(\n            Rayleigh_number &gt;= Rayleigh_critical, Rayleigh_number - Rayleigh_critical, 0\n        )\n    )\n</code></pre>"},{"location":"#seaice3p.equations.equations","title":"<code>equations</code>","text":""},{"location":"#seaice3p.equations.flux","title":"<code>flux</code>","text":"<p>Module for calculating the fluxes using upwind scheme</p>"},{"location":"#seaice3p.equations.flux.bulk_dissolved_gas_flux","title":"<code>bulk_dissolved_gas_flux</code>","text":"<p>calculate the flux terms for the dissolved gas equation in DISEQ model</p>"},{"location":"#seaice3p.equations.flux.gas_fraction_flux","title":"<code>gas_fraction_flux</code>","text":"<p>Calculate gas phase fluxes for disequilibrium model</p>"},{"location":"#seaice3p.equations.flux.heat_flux","title":"<code>heat_flux</code>","text":""},{"location":"#seaice3p.equations.flux.heat_flux.calculate_conductive_heat_flux","title":"<code>calculate_conductive_heat_flux(state_BCs, D_g, cfg)</code>","text":"<p>Calculate conductive heat flux as</p> <p>.. math:: -[(\\phi_l + \\lambda \\phi_s) \\frac{\\partial \\theta}{\\partial z}]</p> <p>:param temperature: temperature including ghost cells :type temperature: Numpy Array of size I+2 :param D_g: difference matrix for ghost grid :type D_g: Numpy Array :param cfg: Simulation configuration :type cfg: seaice3p.params.Config :return: conductive heat flux</p> Source code in <code>seaice3p/equations/flux/heat_flux.py</code> <pre><code>def calculate_conductive_heat_flux(state_BCs, D_g, cfg):\n    r\"\"\"Calculate conductive heat flux as\n\n    .. math:: -[(\\phi_l + \\lambda \\phi_s) \\frac{\\partial \\theta}{\\partial z}]\n\n    :param temperature: temperature including ghost cells\n    :type temperature: Numpy Array of size I+2\n    :param D_g: difference matrix for ghost grid\n    :type D_g: Numpy Array\n    :param cfg: Simulation configuration\n    :type cfg: seaice3p.params.Config\n    :return: conductive heat flux\n\n    \"\"\"\n    temperature = state_BCs.temperature\n    edge_liquid_fraction = geometric(state_BCs.liquid_fraction)\n    edge_solid_fraction = 1 - edge_liquid_fraction\n    conductivity = calculate_conductivity(cfg, edge_solid_fraction)\n    return -conductivity * np.matmul(D_g, temperature)\n</code></pre>"},{"location":"#seaice3p.equations.flux.heat_flux.pure_liquid_switch","title":"<code>pure_liquid_switch(liquid_fraction)</code>","text":"<p>Take the liquid fraction and return a smoothed switch that is equal to 1 in a pure liquid region and goes to zero rapidly outside of this</p> Source code in <code>seaice3p/equations/flux/heat_flux.py</code> <pre><code>def pure_liquid_switch(liquid_fraction: NDArray | float) -&gt; NDArray | float:\n    \"\"\"Take the liquid fraction and return a smoothed switch that is equal to 1 in a\n    pure liquid region and goes to zero rapidly outside of this\"\"\"\n    SCALE = 1e-2\n    return np.exp((liquid_fraction - 1) / SCALE)\n</code></pre>"},{"location":"#seaice3p.equations.flux.salt_flux","title":"<code>salt_flux</code>","text":""},{"location":"#seaice3p.equations.flux.salt_flux.calculate_diffusive_salt_flux","title":"<code>calculate_diffusive_salt_flux(liquid_salinity, liquid_fraction, D_g, cfg)</code>","text":"<p>Take liquid salinity and liquid fraction on ghost grid and interpolate liquid fraction geometrically</p> Source code in <code>seaice3p/equations/flux/salt_flux.py</code> <pre><code>def calculate_diffusive_salt_flux(liquid_salinity, liquid_fraction, D_g, cfg: Config):\n    \"\"\"Take liquid salinity and liquid fraction on ghost grid and interpolate liquid\n    fraction geometrically\"\"\"\n    lewis_salt = cfg.physical_params.lewis_salt\n    edge_liquid_fraction = geometric(liquid_fraction)\n    # In pure liquid phase enhanced eddy diffusivity of dissolved salt\n    salt_diffusivity = edge_liquid_fraction * (\n        (1 / lewis_salt)\n        + cfg.physical_params.eddy_diffusivity_ratio\n        * pure_liquid_switch(edge_liquid_fraction)\n    )\n    return -salt_diffusivity * np.matmul(D_g, liquid_salinity)\n</code></pre>"},{"location":"#seaice3p.equations.nucleation","title":"<code>nucleation</code>","text":""},{"location":"#seaice3p.equations.radiative_heating","title":"<code>radiative_heating</code>","text":"<p>Calculate internal shortwave radiative heating due to oil droplets</p>"},{"location":"#seaice3p.equations.radiative_heating.get_radiative_heating","title":"<code>get_radiative_heating(cfg, grids)</code>","text":"<p>Calculate internal shortwave heating source for enthalpy equation.</p> <p>if the RadForcing object is given as the forcing config then calculates internal heating based on the object given in the configuration for oil_heating.</p> <p>If another forcing is chosen then just returns a function to create an array of zeros as no internal heating is calculated.</p> Source code in <code>seaice3p/equations/radiative_heating.py</code> <pre><code>def get_radiative_heating(cfg: Config, grids: Grids) -&gt; Callable[[StateBCs], NDArray]:\n    \"\"\"Calculate internal shortwave heating source for enthalpy equation.\n\n    if the RadForcing object is given as the forcing config then calculates internal\n    heating based on the object given in the configuration for oil_heating.\n\n    If another forcing is chosen then just returns a function to create an array of\n    zeros as no internal heating is calculated.\n    \"\"\"\n    fun_map = {\n        EQMPhysicalParams: _EQM_radiative_heating,\n        DISEQPhysicalParams: _DISEQ_radiative_heating,\n    }\n\n    def radiative_heating(state_BCs: StateBCs) -&gt; NDArray:\n        return fun_map[type(cfg.physical_params)](state_BCs, cfg, grids)\n\n    return radiative_heating\n</code></pre>"},{"location":"#seaice3p.equations.velocities","title":"<code>velocities</code>","text":"<p>Module to calculate Darcy velocities.</p> <p>The liquid Darcy velocity must be parameterised.</p> <p>The gas Darcy velocity is calculated as gas_fraction x interstitial bubble velocity</p> <p>Interstitial bubble velocity is found by a steady state Stoke's flow calculation. We have implemented two cases mono: All bubbles nucleate and remain the same size power_law: A power law bubble size distribution with fixed max and min.</p>"},{"location":"#seaice3p.equations.velocities.bubble_parameters","title":"<code>bubble_parameters</code>","text":""},{"location":"#seaice3p.equations.velocities.bubble_parameters.calculate_bubble_size_fraction","title":"<code>calculate_bubble_size_fraction(bubble_radius_scaled, liquid_fraction, cfg)</code>","text":"<p>Takes bubble radius scaled and liquid fraction on edges and calculates the bubble size fraction as</p> <p>.. math:: \\lambda = \\Lambda / (\\phi_l^q + \\text{reg})</p> <p>Returns the bubble size fraction on the edge grid.</p> Source code in <code>seaice3p/equations/velocities/bubble_parameters.py</code> <pre><code>def calculate_bubble_size_fraction(bubble_radius_scaled, liquid_fraction, cfg: Config):\n    r\"\"\"Takes bubble radius scaled and liquid fraction on edges and calculates the\n    bubble size fraction as\n\n    .. math:: \\lambda = \\Lambda / (\\phi_l^q + \\text{reg})\n\n    Returns the bubble size fraction on the edge grid.\n    \"\"\"\n    exponent = cfg.bubble_params.pore_throat_scaling\n    reg = cfg.numerical_params.regularisation\n    effective_tube_radius = liquid_fraction**exponent + reg\n    return bubble_radius_scaled / effective_tube_radius\n</code></pre>"},{"location":"#seaice3p.equations.velocities.mono_distribution","title":"<code>mono_distribution</code>","text":""},{"location":"#seaice3p.equations.velocities.mono_distribution.calculate_lag_function","title":"<code>calculate_lag_function(bubble_size_fraction)</code>","text":"<p>Calculate lag function from bubble size fraction on edge grid as</p> <p>.. math:: G(\\lambda) = 1 - \\lambda / 2</p> <p>for 0&lt;lambda&lt;1. Edge cases are given by G(0)=1 and G(1) = 0.5 for values outside this range.</p> Source code in <code>seaice3p/equations/velocities/mono_distribution.py</code> <pre><code>def calculate_lag_function(bubble_size_fraction):\n    r\"\"\"Calculate lag function from bubble size fraction on edge grid as\n\n    .. math:: G(\\lambda) = 1 - \\lambda / 2\n\n    for 0&lt;lambda&lt;1. Edge cases are given by G(0)=1 and G(1) = 0.5 for values outside\n    this range.\n    \"\"\"\n    lag = np.full_like(bubble_size_fraction, np.nan)\n    intermediate = (bubble_size_fraction &lt; 1) &amp; (bubble_size_fraction &gt;= 0)\n    large = bubble_size_fraction &gt;= 1\n    lag[bubble_size_fraction &lt; 0] = 1\n    lag[intermediate] = 1 - 0.5 * bubble_size_fraction[intermediate]\n    lag[large] = 0.5\n    return lag\n</code></pre>"},{"location":"#seaice3p.equations.velocities.mono_distribution.calculate_mono_lag_factor","title":"<code>calculate_mono_lag_factor(liquid_fraction, cfg)</code>","text":"<p>Take liquid fraction on the ghost grid and calculate the lag factor for a mono bubble size distribution as</p> <p>.. math:: I_2 = G(\\lambda)</p> <p>returns lag factor on the edge grid</p> Source code in <code>seaice3p/equations/velocities/mono_distribution.py</code> <pre><code>def calculate_mono_lag_factor(liquid_fraction, cfg: Config):\n    r\"\"\"Take liquid fraction on the ghost grid and calculate the lag factor\n    for a mono bubble size distribution as\n\n    .. math:: I_2 = G(\\lambda)\n\n    returns lag factor on the edge grid\n    \"\"\"\n    bubble_radius_scaled = cfg.bubble_params.bubble_radius_scaled\n    bubble_size_fraction = calculate_bubble_size_fraction(\n        bubble_radius_scaled, geometric(liquid_fraction), cfg\n    )\n    return calculate_lag_function(bubble_size_fraction)\n</code></pre>"},{"location":"#seaice3p.equations.velocities.mono_distribution.calculate_mono_wall_drag_factor","title":"<code>calculate_mono_wall_drag_factor(liquid_fraction, cfg)</code>","text":"<p>Take liquid fraction on the ghost grid and calculate the wall drag factor for a mono bubble size distribution as</p> <p>.. math:: I_1 = \\frac{\\lambda^2}{K(\\lambda)}</p> <p>returns wall drag factor on the edge grid</p> Source code in <code>seaice3p/equations/velocities/mono_distribution.py</code> <pre><code>def calculate_mono_wall_drag_factor(liquid_fraction, cfg: Config):\n    r\"\"\"Take liquid fraction on the ghost grid and calculate the wall drag factor\n    for a mono bubble size distribution as\n\n    .. math:: I_1 = \\frac{\\lambda^2}{K(\\lambda)}\n\n    returns wall drag factor on the edge grid\n    \"\"\"\n    bubble_radius_scaled = cfg.bubble_params.bubble_radius_scaled\n    bubble_size_fraction = calculate_bubble_size_fraction(\n        bubble_radius_scaled, geometric(liquid_fraction), cfg\n    )\n    drag_function = calculate_wall_drag_function(bubble_size_fraction, cfg)\n    drag_factor = drag_function * bubble_size_fraction**2\n    return drag_factor\n</code></pre>"},{"location":"#seaice3p.equations.velocities.mono_distribution.calculate_wall_drag_function","title":"<code>calculate_wall_drag_function(bubble_size_fraction, cfg)</code>","text":"<p>Calculate wall drag function from bubble size fraction on edge grid as</p> <p>.. math:: \\frac{1}{K(\\lambda)} = (1 - \\lambda)^r</p> <p>in the power law case or in the Haberman case from the paper</p> <p>.. math:: \\frac{1}{K(\\lambda)} = \\frac{1 -1.5\\lambda + 1.5\\lambda^5 - \\lambda^6}{1+1.5\\lambda^5}</p> <p>for 0&lt;lambda&lt;1. Edge cases are given by K(0)=1 and K(1) = 0 for values outside this range.</p> Source code in <code>seaice3p/equations/velocities/mono_distribution.py</code> <pre><code>def calculate_wall_drag_function(bubble_size_fraction, cfg: Config):\n    r\"\"\"Calculate wall drag function from bubble size fraction on edge grid as\n\n    .. math:: \\frac{1}{K(\\lambda)} = (1 - \\lambda)^r\n\n    in the power law case or in the Haberman case from the paper\n\n    .. math:: \\frac{1}{K(\\lambda)} = \\frac{1 -1.5\\lambda + 1.5\\lambda^5 - \\lambda^6}{1+1.5\\lambda^5}\n\n    for 0&lt;lambda&lt;1. Edge cases are given by K(0)=1 and K(1) = 0 for values outside\n    this range.\n    \"\"\"\n    drag = np.full_like(bubble_size_fraction, np.nan)\n    intermediate = (bubble_size_fraction &lt; 1) &amp; (bubble_size_fraction &gt;= 0)\n    large = bubble_size_fraction &gt;= 1\n    drag[bubble_size_fraction &lt; 0] = 1\n    drag[intermediate] = (\n        1\n        - 1.5 * bubble_size_fraction[intermediate]\n        + 1.5 * bubble_size_fraction[intermediate] ** 5\n        - bubble_size_fraction[intermediate] ** 6\n    ) / (1 + 1.5 * bubble_size_fraction[intermediate] ** 5)\n    drag[large] = 0\n    return drag\n</code></pre>"},{"location":"#seaice3p.equations.velocities.power_law_distribution","title":"<code>power_law_distribution</code>","text":""},{"location":"#seaice3p.equations.velocities.power_law_distribution.calculate_lag_integrand","title":"<code>calculate_lag_integrand(bubble_size_fraction, cfg)</code>","text":"<p>Scalar function to calculate lag integrand for polydispersive case.</p> <p>Bubble size fraction is given as a scalar input to calculate</p> <p>.. math:: \\lambda^{3-p} G(\\lambda)</p> Source code in <code>seaice3p/equations/velocities/power_law_distribution.py</code> <pre><code>def calculate_lag_integrand(bubble_size_fraction: float, cfg: Config):\n    r\"\"\"Scalar function to calculate lag integrand for polydispersive case.\n\n    Bubble size fraction is given as a scalar input to calculate\n\n    .. math:: \\lambda^{3-p} G(\\lambda)\n\n    \"\"\"\n    power_law = cfg.bubble_params.bubble_distribution_power\n    if bubble_size_fraction &lt; 0:\n        return 0\n    elif (bubble_size_fraction &gt;= 0) and (bubble_size_fraction &lt; 1):\n        return (1 - 0.5 * bubble_size_fraction) * (\n            bubble_size_fraction ** (3 - power_law)\n        )\n    else:\n        return 0.5\n</code></pre>"},{"location":"#seaice3p.equations.velocities.power_law_distribution.calculate_power_law_lag_factor","title":"<code>calculate_power_law_lag_factor(liquid_fraction, cfg)</code>","text":"<p>Take liquid fraction on the ghost grid and calculate the lag factor for power law bubble size distribution.</p> <p>Return on edge grid</p> Source code in <code>seaice3p/equations/velocities/power_law_distribution.py</code> <pre><code>def calculate_power_law_lag_factor(liquid_fraction, cfg: Config):\n    r\"\"\"Take liquid fraction on the ghost grid and calculate the lag factor\n    for power law bubble size distribution.\n\n    Return on edge grid\n    \"\"\"\n    minimum_size_fractions = calculate_bubble_size_fraction(\n        cfg.bubble_params.minimum_bubble_radius_scaled,\n        geometric(liquid_fraction),\n        cfg,\n    )\n    maximum_size_fractions = calculate_bubble_size_fraction(\n        cfg.bubble_params.maximum_bubble_radius_scaled,\n        geometric(liquid_fraction),\n        cfg,\n    )\n    lag_factor = np.full_like(minimum_size_fractions, np.nan)\n    for i, (min, max) in enumerate(zip(minimum_size_fractions, maximum_size_fractions)):\n        lag_factor[i] = calculate_lag_integral(min, max, cfg)\n    return lag_factor\n</code></pre>"},{"location":"#seaice3p.equations.velocities.power_law_distribution.calculate_power_law_wall_drag_factor","title":"<code>calculate_power_law_wall_drag_factor(liquid_fraction, cfg)</code>","text":"<p>Take liquid fraction on the ghost grid and calculate the wall drag factor for power law bubble size distribution.</p> <p>Return on edge grid</p> Source code in <code>seaice3p/equations/velocities/power_law_distribution.py</code> <pre><code>def calculate_power_law_wall_drag_factor(liquid_fraction, cfg: Config):\n    r\"\"\"Take liquid fraction on the ghost grid and calculate the wall drag factor\n    for power law bubble size distribution.\n\n    Return on edge grid\n    \"\"\"\n    minimum_size_fractions = calculate_bubble_size_fraction(\n        cfg.bubble_params.minimum_bubble_radius_scaled,\n        geometric(liquid_fraction),\n        cfg,\n    )\n    maximum_size_fractions = calculate_bubble_size_fraction(\n        cfg.bubble_params.maximum_bubble_radius_scaled,\n        geometric(liquid_fraction),\n        cfg,\n    )\n    drag_factor = np.full_like(minimum_size_fractions, np.nan)\n    for i, (min, max) in enumerate(zip(minimum_size_fractions, maximum_size_fractions)):\n        drag_factor[i] = calculate_wall_drag_integral(min, max, cfg)\n    return drag_factor\n</code></pre>"},{"location":"#seaice3p.equations.velocities.power_law_distribution.calculate_volume_integrand","title":"<code>calculate_volume_integrand(bubble_size_fraction, cfg)</code>","text":"<p>Scalar function to calculate the integrand for volume under a power law bubble size distribution given as</p> <p>.. math:: \\lambda^{3-p}</p> <p>in terms of the bubble size fraction.</p> Source code in <code>seaice3p/equations/velocities/power_law_distribution.py</code> <pre><code>def calculate_volume_integrand(bubble_size_fraction: float, cfg: Config):\n    r\"\"\"Scalar function to calculate the integrand for volume under a power law\n    bubble size distribution given as\n\n    .. math:: \\lambda^{3-p}\n\n    in terms of the bubble size fraction.\n    \"\"\"\n    p = cfg.bubble_params.bubble_distribution_power\n    return bubble_size_fraction ** (3 - p)\n</code></pre>"},{"location":"#seaice3p.equations.velocities.power_law_distribution.calculate_wall_drag_integrand","title":"<code>calculate_wall_drag_integrand(bubble_size_fraction, cfg)</code>","text":"<p>Scalar function to calculate wall drag integrand for polydispersive case.</p> <p>Bubble size fraction is given as a scalar input to calculate</p> <p>.. math:: \\frac{\\lambda^{5-p}}{K(\\lambda)}</p> <p>where the wall drag enhancement funciton K can be given by a power law fit or taken from the Haberman paper.</p> Source code in <code>seaice3p/equations/velocities/power_law_distribution.py</code> <pre><code>def calculate_wall_drag_integrand(bubble_size_fraction: float, cfg: Config):\n    r\"\"\"Scalar function to calculate wall drag integrand for polydispersive case.\n\n    Bubble size fraction is given as a scalar input to calculate\n\n    .. math:: \\frac{\\lambda^{5-p}}{K(\\lambda)}\n\n    where the wall drag enhancement funciton K can be given by a power law fit\n    or taken from the Haberman paper.\n    \"\"\"\n    power_law = cfg.bubble_params.bubble_distribution_power\n    if bubble_size_fraction &lt; 0:\n        return 0\n    elif (bubble_size_fraction &gt;= 0) and (bubble_size_fraction &lt; 1):\n        return (\n            (\n                1\n                - 1.5 * bubble_size_fraction\n                + 1.5 * bubble_size_fraction**5\n                - bubble_size_fraction**6\n            )\n            / (1 + 1.5 * bubble_size_fraction**5)\n        ) * (bubble_size_fraction ** (5 - power_law))\n    else:\n        return 0\n</code></pre>"},{"location":"#seaice3p.equations.velocities.velocities","title":"<code>velocities</code>","text":""},{"location":"#seaice3p.equations.velocities.velocities.calculate_gas_interstitial_velocity","title":"<code>calculate_gas_interstitial_velocity(liquid_fraction, liquid_darcy_velocity, wall_drag_factor, lag_factor, cfg)</code>","text":"<p>Calculate Vg from liquid fraction on the ghost frid and liquid interstitial velocity</p> <p>.. math:: V_g = \\mathcal{B} (\\phi_l^{2q} I_1) + U_0 I_2</p> <p>Return Vg on edge grid</p> Source code in <code>seaice3p/equations/velocities/velocities.py</code> <pre><code>def calculate_gas_interstitial_velocity(\n    liquid_fraction,\n    liquid_darcy_velocity,\n    wall_drag_factor,\n    lag_factor,\n    cfg: Config,\n):\n    r\"\"\"Calculate Vg from liquid fraction on the ghost frid and liquid interstitial velocity\n\n    .. math:: V_g = \\mathcal{B} (\\phi_l^{2q} I_1) + U_0 I_2\n\n    Return Vg on edge grid\n    \"\"\"\n    B = cfg.bubble_params.B\n    exponent = cfg.bubble_params.pore_throat_scaling\n\n    REGULARISATION = 1e-10\n    liquid_interstitial_velocity = (\n        liquid_darcy_velocity * 2 / (geometric(liquid_fraction) + REGULARISATION)\n    )\n\n    viscosity_factor = (\n        2\n        * (1 + cfg.physical_params.gas_viscosity_ratio)\n        / (2 + 3 * cfg.physical_params.gas_viscosity_ratio)\n    )\n    Vg = (\n        viscosity_factor\n        * B\n        * wall_drag_factor\n        * geometric(liquid_fraction) ** (2 * exponent)\n        + liquid_interstitial_velocity * lag_factor\n    )\n\n    # apply a porosity cutoff to the gas interstitial velocity if necking occurs below\n    # critical porosity.\n    if cfg.bubble_params.porosity_threshold:\n        return Vg * np.heaviside(\n            geometric(liquid_fraction) - cfg.bubble_params.porosity_threshold_value,\n            0,\n        )\n\n    return Vg\n</code></pre>"},{"location":"#seaice3p.equations.velocities.velocities.calculate_liquid_darcy_velocity","title":"<code>calculate_liquid_darcy_velocity(liquid_fraction, liquid_salinity, center_grid, edge_grid, cfg)</code>","text":"<p>Calculate liquid Darcy velocity either using brine convection parameterisation or as stagnant</p> <p>:param liquid_fraction: liquid fraction on ghost grid :type liquid_fraction: Numpy Array (size I+2) :param liquid_salinity: liquid salinity on ghost grid :type liquid_salinity: Numpy Array (size I+2) :param center_grid: vertical coordinates of cell centers :type center_grid: Numpy Array of shape (I,) :param edge_grid: Vertical coordinates of cell edges :type edge_grid: Numpy Array (size I+1) :param cfg: simulation configuration object :type cfg: seaice3p.params.Config :return: liquid darcy velocity on edge grid</p> Source code in <code>seaice3p/equations/velocities/velocities.py</code> <pre><code>def calculate_liquid_darcy_velocity(\n    liquid_fraction, liquid_salinity, center_grid, edge_grid, cfg: Config\n):\n    r\"\"\"Calculate liquid Darcy velocity either using brine convection parameterisation\n    or as stagnant\n\n\n    :param liquid_fraction: liquid fraction on ghost grid\n    :type liquid_fraction: Numpy Array (size I+2)\n    :param liquid_salinity: liquid salinity on ghost grid\n    :type liquid_salinity: Numpy Array (size I+2)\n    :param center_grid: vertical coordinates of cell centers\n    :type center_grid: Numpy Array of shape (I,)\n    :param edge_grid: Vertical coordinates of cell edges\n    :type edge_grid: Numpy Array (size I+1)\n    :param cfg: simulation configuration object\n    :type cfg: seaice3p.params.Config\n    :return: liquid darcy velocity on edge grid\n    \"\"\"\n    if isinstance(cfg.brine_convection_params, NoBrineConvection):\n        return np.zeros_like(geometric(liquid_fraction))\n\n    Wl = calculate_brine_convection_liquid_velocity(\n        liquid_fraction[1:-1], liquid_salinity[1:-1], center_grid, edge_grid, cfg\n    )\n    return Wl\n</code></pre>"},{"location":"#seaice3p.equations.velocities.velocities.calculate_velocities","title":"<code>calculate_velocities(state_BCs, cfg)</code>","text":"<p>Inputs on ghost grid, outputs on edge grid</p> <p>needs the simulation config, liquid fraction, liquid salinity and grids</p> Source code in <code>seaice3p/equations/velocities/velocities.py</code> <pre><code>def calculate_velocities(state_BCs, cfg: Config):\n    \"\"\"Inputs on ghost grid, outputs on edge grid\n\n    needs the simulation config, liquid fraction, liquid salinity and grids\n    \"\"\"\n    liquid_fraction = state_BCs.liquid_fraction\n    liquid_salinity = state_BCs.liquid_salinity\n    center_grid, edge_grid = (\n        Grids(cfg.numerical_params.I).centers,\n        Grids(cfg.numerical_params.I).edges,\n    )\n\n    match cfg.bubble_params:\n        case MonoBubbleParams():\n            wall_drag_factor = calculate_mono_wall_drag_factor(liquid_fraction, cfg)\n            lag_factor = calculate_mono_lag_factor(liquid_fraction, cfg)\n        case PowerLawBubbleParams():\n            wall_drag_factor = calculate_power_law_wall_drag_factor(\n                liquid_fraction, cfg\n            )\n            lag_factor = calculate_power_law_lag_factor(liquid_fraction, cfg)\n        case _:\n            raise NotImplementedError\n\n    # check if we want to couple the bubble to fluid motion in the vertical\n    if not isinstance(cfg.brine_convection_params, NoBrineConvection):\n        if not cfg.brine_convection_params.couple_bubble_to_vertical_flow:\n            lag_factor = np.zeros_like(wall_drag_factor)\n\n    Wl = calculate_liquid_darcy_velocity(\n        liquid_fraction, liquid_salinity, center_grid, edge_grid, cfg\n    )\n    Vg = calculate_gas_interstitial_velocity(\n        liquid_fraction, Wl, wall_drag_factor, lag_factor, cfg\n    )\n    V = calculate_frame_velocity(cfg)\n    return Vg, Wl, V\n</code></pre>"},{"location":"#seaice3p.example","title":"<code>example</code>","text":"<p>Script to run a simulation starting with dimensional parameters and plot output</p>"},{"location":"#seaice3p.example.main","title":"<code>main(data_directory, frames_directory, simulation_dimensional_params)</code>","text":"<p>Generate non dimensional simulation config and save along with dimensional config then run simulation and save data.</p> Source code in <code>seaice3p/example.py</code> <pre><code>def main(\n    data_directory: Path,\n    frames_directory: Path,\n    simulation_dimensional_params: DimensionalParams,\n):\n    \"\"\"Generate non dimensional simulation config and save along with dimensional\n    config then run simulation and save data.\n    \"\"\"\n\n    print(f\"seaice3p version {__version__}\")\n\n    cfg = create_and_save_config(data_directory, simulation_dimensional_params)\n    solve(cfg, data_directory, verbosity_level=1)\n\n    # Analysis load simulation data\n    # plot:\n    # gas_fraction\n    # salt\n    # temperature\n    # solid_fraction\n    # save as frames in frames/gas_fraction etc...\n    simulation_name = simulation_dimensional_params.name\n    DIMENSIONAL_CONFIG_DATA_PATH = data_directory / f\"{simulation_name}_dimensional.yml\"\n    results = load_simulation(\n        DATA_DIRECTORY / \"example_dimensional.yml\",\n        DATA_DIRECTORY / \"example.npz\",\n        is_dimensional=True,\n    )\n\n    scales = results.cfg.scales\n    dimensional_grid = scales.convert_to_dimensional_grid(results.grids.centers)\n    dimensional_times = scales.convert_to_dimensional_time(results.times)\n\n    GAS_FRACTION_DIR = frames_directory / \"gas_fraction/\"\n    GAS_FRACTION_DIR.mkdir(exist_ok=True, parents=True)\n\n    TEMPERATURE_DIR = frames_directory / \"temperature/\"\n    TEMPERATURE_DIR.mkdir(exist_ok=True, parents=True)\n\n    SOLID_FRAC_DIR = frames_directory / \"solid_fraction/\"\n    SOLID_FRAC_DIR.mkdir(exist_ok=True, parents=True)\n\n    BULK_AIR_DIR = frames_directory / \"bulk_air/\"\n    BULK_AIR_DIR.mkdir(exist_ok=True, parents=True)\n\n    BULK_SALT_DIR = frames_directory / \"bulk_salt/\"\n    BULK_SALT_DIR.mkdir(exist_ok=True, parents=True)\n\n    for n, state in enumerate(results.states):\n        plt.figure(figsize=(5, 5))\n        plt.plot(\n            state.gas_fraction,\n            dimensional_grid,\n            \"g*--\",\n        )\n        plt.title(f\"{dimensional_times[n]:.0f} days\")\n        plt.xlabel(\"gas fraction\")\n        plt.ylabel(\"depth [m]\")\n        plt.savefig(GAS_FRACTION_DIR / f\"gas_fraction{n}.pdf\")\n        plt.close()\n\n        plt.figure(figsize=(5, 5))\n        plt.plot(\n            scales.convert_to_dimensional_bulk_salinity(state.salt),\n            dimensional_grid,\n            \"b*--\",\n        )\n        plt.title(f\"{dimensional_times[n]:.0f} days\")\n        plt.xlabel(\"bulk salinity [g/kg]\")\n        plt.ylabel(\"depth [m]\")\n        plt.savefig(BULK_SALT_DIR / f\"bulk_salt{n}.pdf\")\n        plt.close()\n\n        plt.figure(figsize=(5, 5))\n        dimensional_temperature = scales.convert_to_dimensional_temperature(\n            state.temperature\n        )\n        plt.plot(\n            dimensional_temperature,\n            dimensional_grid,\n            \"r*--\",\n        )\n        plt.title(f\"{dimensional_times[n]:.0f} days\")\n        plt.xlabel(\"temperature [deg C]\")\n        plt.ylabel(\"depth [m]\")\n        plt.savefig(TEMPERATURE_DIR / f\"temperature{n}.pdf\")\n        plt.close()\n\n        plt.figure(figsize=(5, 5))\n        plt.plot(\n            state.solid_fraction,\n            dimensional_grid,\n            \"m*--\",\n        )\n        plt.title(f\"{dimensional_times[n]:.0f} days\")\n        plt.xlabel(\"solid fraction\")\n        plt.ylabel(\"depth [m]\")\n        plt.savefig(SOLID_FRAC_DIR / f\"solid_fraction{n}.pdf\")\n        plt.close()\n\n        plt.figure(figsize=(5, 5))\n        dimensional_bulk_air = scales.convert_to_dimensional_bulk_gas(state.gas)\n        argon_micromole_per_liter = (\n            scales.convert_dimensional_bulk_air_to_argon_content(dimensional_bulk_air)\n        )\n        plt.plot(\n            argon_micromole_per_liter,\n            dimensional_grid,\n            \"m*--\",\n        )\n        plt.title(f\"{dimensional_times[n]:.0f} days\")\n        plt.xlabel(\"bulk argon [micromole/L]\")\n        plt.ylabel(\"depth [m]\")\n        plt.savefig(BULK_AIR_DIR / f\"bulk_air{n}.pdf\")\n        plt.close()\n\n    for converter, unit, attr in zip(\n        [\n            scales.convert_to_dimensional_temperature,\n            scales.convert_to_dimensional_bulk_salinity,\n            lambda x: x,\n            lambda x: x,\n            scales.convert_to_dimensional_bulk_gas,\n        ],\n        [\"[deg C]\", \"[g/kg]\", \"\", \"\", \"[kg/m3]\"],\n        [\"temperature\", \"salt\", \"gas_fraction\", \"solid_fraction\", \"bulk_gas\"],\n    ):\n        plt.figure()\n        plt.contourf(\n            dimensional_times, dimensional_grid, converter(getattr(results, attr))\n        )\n        plt.colorbar()\n        plt.title(f\"{attr} {unit}\")\n        plt.xlabel(\"time [days]\")\n        plt.ylabel(\"depth [m]\")\n        plt.savefig(data_directory / f\"contours_{attr}.pdf\")\n</code></pre>"},{"location":"#seaice3p.forcing","title":"<code>forcing</code>","text":""},{"location":"#seaice3p.forcing.boundary_conditions","title":"<code>boundary_conditions</code>","text":"<p>Module to provide functions to add boundary conditions to each quantity on the centered grid that needs to be on the ghost grid for the upwind scheme.</p>"},{"location":"#seaice3p.forcing.radiative_forcing","title":"<code>radiative_forcing</code>","text":"<p>Module for providing surface radiative forcing to simulation.</p> <p>Currently only total surface shortwave irradiance (integrated over entire shortwave part of the spectrum) is provided and this is used to calculate internal radiative heating.</p> <p>Unlike temperature forcing this provides dimensional forcing</p>"},{"location":"#seaice3p.forcing.surface_energy_balance","title":"<code>surface_energy_balance</code>","text":""},{"location":"#seaice3p.forcing.surface_energy_balance.surface_energy_balance","title":"<code>surface_energy_balance</code>","text":"<p>Module to compute the surface heat flux from geophysical energy balance</p> <p>following [1]</p> <p>Refs: [1] P. D. Taylor and D. L. Feltham, \u2018A model of melt pond evolution on sea ice\u2019, J. Geophys. Res., vol. 109, no. C12, p. 2004JC002361, Dec. 2004, doi: 10.1029/2004JC002361.</p>"},{"location":"#seaice3p.forcing.surface_energy_balance.surface_energy_balance.find_ghost_cell_temperature","title":"<code>find_ghost_cell_temperature(state, cfg)</code>","text":"<p>Returns non dimensional ghost cell temperature such that surface heat flux is the sum of incoming LW, outgoing LW, sensible and latent heat fluxes. The SW heat flux is determined in the radiative heating term.</p> Source code in <code>seaice3p/forcing/surface_energy_balance/surface_energy_balance.py</code> <pre><code>def find_ghost_cell_temperature(state: StateFull, cfg: Config) -&gt; float:\n    \"\"\"Returns non dimensional ghost cell temperature such that surface heat flux\n    is the sum of incoming LW, outgoing LW, sensible and latent heat fluxes.\n    The SW heat flux is determined in the radiative heating term.\"\"\"\n    if state.solid_fraction[-1] == 0:\n        top_cell_is_ice = False\n    else:\n        top_cell_is_ice = True\n\n    def residual(ghost_cell_temperature: float) -&gt; float:\n        surface_temperature = 0.5 * (ghost_cell_temperature + state.temperature[-1])\n        temp_gradient = (1 / cfg.numerical_params.step) * (\n            ghost_cell_temperature - state.temperature[-1]\n        )\n        conductivity = calculate_conductivity(cfg, state.solid_fraction[-1])\n        return conductivity * temp_gradient - _calculate_total_heat_flux(\n            cfg,\n            state.time,\n            top_cell_is_ice,\n            surface_temperature,\n            temp_gradient,\n            conductivity,\n        )\n\n    initial_guess = state.temperature[-1]\n    solution = fsolve(residual, initial_guess)[0]\n    return solution\n</code></pre>"},{"location":"#seaice3p.forcing.surface_energy_balance.turbulent_heat_flux","title":"<code>turbulent_heat_flux</code>","text":"<p>Module to compute the turbulent atmospheric sensible and latent heat fluxes</p> <p>All temperatures are in Kelvin in this module</p> <p>Refs: [1] P. D. Taylor and D. L. Feltham, \u2018A model of melt pond evolution on sea ice\u2019, J. Geophys. Res., vol. 109, no. C12, p. 2004JC002361, Dec. 2004, doi: 10.1029/2004JC002361.</p> <p>[2] E. E. Ebert and J. A. Curry, \u2018An intermediate one-dimensional thermodynamic sea ice model for investigating ice-atmosphere interactions\u2019, Journal of Geophysical Research: Oceans, vol. 98, no. C6, pp. 10085\u201310109, 1993, doi: 10.1029/93JC00656.</p>"},{"location":"#seaice3p.forcing.surface_energy_balance.turbulent_heat_flux.calculate_latent_heat_flux","title":"<code>calculate_latent_heat_flux(cfg, time, top_cell_is_ice, surface_temp)</code>","text":"<p>Calculate latent heat flux from [2]</p> Source code in <code>seaice3p/forcing/surface_energy_balance/turbulent_heat_flux.py</code> <pre><code>def calculate_latent_heat_flux(\n    cfg: Config, time: float, top_cell_is_ice: bool, surface_temp: float\n) -&gt; float:\n    \"\"\"Calculate latent heat flux from [2]\"\"\"\n    air_density = cfg.forcing_config.turbulent_flux.air_density\n    air_latent_heat_of_vaporisation = (\n        cfg.forcing_config.turbulent_flux.air_latent_heat_of_vaporisation\n    )\n    windspeed = _calculate_ref_windspeed(cfg, time)\n    ref_specific_humidity = _calculate_ref_specific_humidity(cfg, time)\n    bulk_transfer_coeff = _calculate_bulk_transfer_coefficient(\n        cfg, top_cell_is_ice, time, surface_temp\n    )\n    surface_specific_humidity = _calculate_surface_specific_humidity(\n        cfg, time, surface_temp\n    )\n    return (\n        air_density\n        * air_latent_heat_of_vaporisation\n        * bulk_transfer_coeff\n        * windspeed\n        * (ref_specific_humidity - surface_specific_humidity)\n    )\n</code></pre>"},{"location":"#seaice3p.forcing.surface_energy_balance.turbulent_heat_flux.calculate_sensible_heat_flux","title":"<code>calculate_sensible_heat_flux(cfg, time, top_cell_is_ice, surface_temp)</code>","text":"<p>Calculate sensible heat flux from [2]</p> Source code in <code>seaice3p/forcing/surface_energy_balance/turbulent_heat_flux.py</code> <pre><code>def calculate_sensible_heat_flux(\n    cfg: Config, time: float, top_cell_is_ice: bool, surface_temp: float\n) -&gt; float:\n    \"\"\"Calculate sensible heat flux from [2]\"\"\"\n    air_density = cfg.forcing_config.turbulent_flux.air_density\n    air_heat_capacity = cfg.forcing_config.turbulent_flux.air_heat_capacity\n    ref_air_temp = _calculate_ref_air_temp(cfg, time)\n    windspeed = _calculate_ref_windspeed(cfg, time)\n    bulk_transfer_coeff = _calculate_bulk_transfer_coefficient(\n        cfg, top_cell_is_ice, time, surface_temp\n    )\n    return (\n        air_density\n        * air_heat_capacity\n        * bulk_transfer_coeff\n        * windspeed\n        * (ref_air_temp - surface_temp)\n    )\n</code></pre>"},{"location":"#seaice3p.forcing.temperature_forcing","title":"<code>temperature_forcing</code>","text":"<p>Module for providing surface temperature forcing to simulation.</p> <p>Note that the barrow temperature data is read in from a file if needed by the simulation configuration.</p>"},{"location":"#seaice3p.grids","title":"<code>grids</code>","text":"<p>Module providing functions to initialise the different grids and interpolate quantities between them.</p>"},{"location":"#seaice3p.grids.Grids","title":"<code>Grids</code>  <code>dataclass</code>","text":"<p>Class initialised from number of grid cells to contain:</p> <p>grid cell width, center, edge and ghost grids and difference matrices</p> Source code in <code>seaice3p/grids.py</code> <pre><code>@dataclass(frozen=True)\nclass Grids:\n    \"\"\"Class initialised from number of grid cells to contain:\n\n    grid cell width, center, edge and ghost grids and difference matrices\n    \"\"\"\n\n    number_of_cells: int\n\n    @cached_property\n    def step(self) -&gt; float:\n        \"\"\"Grid cell width\"\"\"\n        return 1 / self.number_of_cells\n\n    @cached_property\n    def centers(self) -&gt; NDArray:\n        \"\"\"Center grid\"\"\"\n        return np.array(\n            [-1 + (2 * i + 1) * self.step / 2 for i in range(self.number_of_cells)]\n        )\n\n    @cached_property\n    def edges(self) -&gt; NDArray:\n        \"\"\"Edge grid\"\"\"\n        return np.array([-1 + i * self.step for i in range(self.number_of_cells + 1)])\n\n    @cached_property\n    def ghosts(self) -&gt; NDArray:\n        \"\"\"Ghost grid\"\"\"\n        return np.concatenate(\n            (np.array([-1 - self.step / 2]), self.centers, np.array([self.step / 2]))\n        )\n\n    @cached_property\n    def D_e(self) -&gt; NDArray:\n        \"\"\"Difference matrix to differentiate edge grid quantities to the center grid\"\"\"\n        return get_difference_matrix(self.number_of_cells, self.step)\n\n    @cached_property\n    def D_g(self) -&gt; NDArray:\n        \"\"\"Difference matrix to differentiate ghost grid quantities to the edge grid\"\"\"\n        return get_difference_matrix(self.number_of_cells + 1, self.step)\n</code></pre>"},{"location":"#seaice3p.grids.Grids.D_e","title":"<code>D_e</code>  <code>cached</code> <code>property</code>","text":"<p>Difference matrix to differentiate edge grid quantities to the center grid</p>"},{"location":"#seaice3p.grids.Grids.D_g","title":"<code>D_g</code>  <code>cached</code> <code>property</code>","text":"<p>Difference matrix to differentiate ghost grid quantities to the edge grid</p>"},{"location":"#seaice3p.grids.Grids.centers","title":"<code>centers</code>  <code>cached</code> <code>property</code>","text":"<p>Center grid</p>"},{"location":"#seaice3p.grids.Grids.edges","title":"<code>edges</code>  <code>cached</code> <code>property</code>","text":"<p>Edge grid</p>"},{"location":"#seaice3p.grids.Grids.ghosts","title":"<code>ghosts</code>  <code>cached</code> <code>property</code>","text":"<p>Ghost grid</p>"},{"location":"#seaice3p.grids.Grids.step","title":"<code>step</code>  <code>cached</code> <code>property</code>","text":"<p>Grid cell width</p>"},{"location":"#seaice3p.grids.add_ghost_cells","title":"<code>add_ghost_cells(centers, bottom, top)</code>","text":"<p>Add specified bottom and top value to center grid</p> <p>:param centers: numpy array on centered grid (size I). :type centers: Numpy array :param bottom: bottom value placed at index 0. :type bottom: float :param top: top value placed at index -1. :type top: float :return: numpy array on ghost grid (size I+2).</p> Source code in <code>seaice3p/grids.py</code> <pre><code>def add_ghost_cells(centers, bottom, top):\n    \"\"\"Add specified bottom and top value to center grid\n\n    :param centers: numpy array on centered grid (size I).\n    :type centers: Numpy array\n    :param bottom: bottom value placed at index 0.\n    :type bottom: float\n    :param top: top value placed at index -1.\n    :type top: float\n    :return: numpy array on ghost grid (size I+2).\n    \"\"\"\n    return np.concatenate((np.array([bottom]), centers, np.array([top])))\n</code></pre>"},{"location":"#seaice3p.grids.average","title":"<code>average(points)</code>","text":"<p>Returns arithmetic mean of adjacent points in an array</p> <p>takes ghosts -&gt; edges -&gt; centers</p> Source code in <code>seaice3p/grids.py</code> <pre><code>def average(points: NDArray) -&gt; NDArray:\n    \"\"\"Returns arithmetic mean of adjacent points in an array\n\n    takes ghosts -&gt; edges -&gt; centers\n    \"\"\"\n    upper = points[1:]\n    lower = points[:-1]\n    return 0.5 * (upper + lower)\n</code></pre>"},{"location":"#seaice3p.grids.calculate_ice_ocean_boundary_depth","title":"<code>calculate_ice_ocean_boundary_depth(liquid_fraction, edge_grid)</code>","text":"<p>Calculate the depth of the ice ocean boundary as the edge position of the first cell from the bottom to be not completely liquid. I.e the first time the liquid fraction goes below 1.</p> <p>If the ice has made it to the bottom of the domain raise an error.</p> <p>If the domain is completely liquid set h=0.</p> <p>NOTE: depth is a positive quantity and our grid coordinate increases from -1 at the bottom of the domain to 0 at the top.</p> <p>:param liquid_fraction: liquid fraction on center grid :type liquid_fraction: Numpy Array (size I) :param edge_grid: The vertical coordinate positions of the edge grid. :type edge_grid: Numpy Array (size I+1) :return: positive depth value of ice ocean interface</p> Source code in <code>seaice3p/grids.py</code> <pre><code>def calculate_ice_ocean_boundary_depth(liquid_fraction, edge_grid):\n    r\"\"\"Calculate the depth of the ice ocean boundary as the edge position of the\n    first cell from the bottom to be not completely liquid. I.e the first time the\n    liquid fraction goes below 1.\n\n    If the ice has made it to the bottom of the domain raise an error.\n\n    If the domain is completely liquid set h=0.\n\n    NOTE: depth is a positive quantity and our grid coordinate increases from -1 at the\n    bottom of the domain to 0 at the top.\n\n    :param liquid_fraction: liquid fraction on center grid\n    :type liquid_fraction: Numpy Array (size I)\n    :param edge_grid: The vertical coordinate positions of the edge grid.\n    :type edge_grid: Numpy Array (size I+1)\n    :return: positive depth value of ice ocean interface\n    \"\"\"\n    # locate index on center grid where liquid fraction first drops below 1\n    index = np.argmax(liquid_fraction &lt; 1)\n\n    # if domain is completely liquid set h=0\n    if np.all(liquid_fraction == 1):\n        index = edge_grid.size - 1\n\n    # raise error if bottom of domain freezes\n    if index == 0:\n        raise ValueError(\"Ice ocean interface has reached bottom of domain\")\n\n    # ice interface is at bottom edge of first frozen cell\n    depth = (-1) * edge_grid[index]\n    return depth\n</code></pre>"},{"location":"#seaice3p.grids.geometric","title":"<code>geometric(ghosts)</code>","text":"<p>Returns geometric mean of the first dimension of an array</p> Source code in <code>seaice3p/grids.py</code> <pre><code>def geometric(ghosts):\n    \"\"\"Returns geometric mean of the first dimension of an array\"\"\"\n    upper_ghosts = ghosts[1:]\n    lower_ghosts = ghosts[:-1]\n    return np.sqrt(upper_ghosts * lower_ghosts)\n</code></pre>"},{"location":"#seaice3p.initial_conditions","title":"<code>initial_conditions</code>","text":"<p>Module to provide initial state of bulk enthalpy, bulk salinity and bulk gas for the simulation.</p>"},{"location":"#seaice3p.load","title":"<code>load</code>","text":""},{"location":"#seaice3p.load.DISEQResults","title":"<code>DISEQResults</code>  <code>dataclass</code>","text":"<p>               Bases: <code>_BaseResults</code></p> Source code in <code>seaice3p/load.py</code> <pre><code>@dataclass\nclass DISEQResults(_BaseResults):\n    bulk_dissolved_gas: NDArray\n    gas_fraction: NDArray\n\n    def _get_state(self, time: float) -&gt; DISEQStateFull:\n        index = self._get_index(time)\n        state = DISEQState(\n            self.times[index],\n            self.enthalpy[:, index],\n            self.salt[:, index],\n            self.bulk_dissolved_gas[:, index],\n            self.gas_fraction[:, index],\n        )\n\n        enthalpy_method = get_enthalpy_method(self.cfg)\n        return enthalpy_method(state)\n\n    @property\n    def bulk_gas(self) -&gt; NDArray:\n        \"\"\"Dimensionless bulk gas the same as the EQM model\"\"\"\n        return self.bulk_dissolved_gas + self.gas_fraction\n</code></pre>"},{"location":"#seaice3p.load.DISEQResults.bulk_gas","title":"<code>bulk_gas</code>  <code>property</code>","text":"<p>Dimensionless bulk gas the same as the EQM model</p>"},{"location":"#seaice3p.oil_mass","title":"<code>oil_mass</code>","text":""},{"location":"#seaice3p.oil_mass.convert_gas_fraction_to_oil_mass_ratio","title":"<code>convert_gas_fraction_to_oil_mass_ratio(gas_fraction, oil_density, ice_density)</code>","text":"<p>Convert gas (oil) volume fraction to oil mass ratio in ng/g</p> Source code in <code>seaice3p/oil_mass.py</code> <pre><code>def convert_gas_fraction_to_oil_mass_ratio(\n    gas_fraction: NDArray, oil_density: float, ice_density: float\n) -&gt; NDArray:\n    \"\"\"Convert gas (oil) volume fraction to oil mass ratio in ng/g\"\"\"\n    return gas_fraction * 1e9 * oil_density / ice_density\n</code></pre>"},{"location":"#seaice3p.oil_mass.convert_oil_mass_ratio_to_gas_fraction","title":"<code>convert_oil_mass_ratio_to_gas_fraction(oil_mass_ratio, oil_density, ice_density)</code>","text":"<p>Convert oil mass ratio in ng/g to gas (oil) volume fraction</p> Source code in <code>seaice3p/oil_mass.py</code> <pre><code>def convert_oil_mass_ratio_to_gas_fraction(\n    oil_mass_ratio: NDArray, oil_density: float, ice_density: float\n) -&gt; NDArray:\n    \"\"\"Convert oil mass ratio in ng/g to gas (oil) volume fraction\"\"\"\n    return oil_mass_ratio * 1e-9 * ice_density / oil_density\n</code></pre>"},{"location":"#seaice3p.params","title":"<code>params</code>","text":""},{"location":"#seaice3p.params.BRW09InitialConditions","title":"<code>BRW09InitialConditions</code>  <code>dataclass</code>","text":"<p>values for bottom (ocean) boundary</p> Source code in <code>seaice3p/params/dimensional/initial_conditions.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass BRW09InitialConditions:\n    \"\"\"values for bottom (ocean) boundary\"\"\"\n\n    Barrow_initial_bulk_gas_in_ice: float = 1 / 5\n</code></pre>"},{"location":"#seaice3p.params.CubicLiquidus","title":"<code>CubicLiquidus</code>  <code>dataclass</code>","text":"<p>Cubic fit to liquidus to give liquidus salinity in terms of temperature</p> <p>S = a0 + a1 T + a2 T^2 + a3 T^3</p> <p>defaults are taken from Notz PhD thesis for fit to Assur seawater data</p> Source code in <code>seaice3p/params/dimensional/water.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass CubicLiquidus:\n    \"\"\"Cubic fit to liquidus to give liquidus salinity in terms of temperature\n\n    S = a0 + a1 T + a2 T^2 + a3 T^3\n\n    defaults are taken from Notz PhD thesis for fit to Assur seawater data\n    \"\"\"\n\n    eutectic_temperature: float = -21.1  # deg Celsius\n    a0: float = -1.2\n    a1: float = -21.8\n    a2: float = -0.919\n    a3: float = -0.0178\n\n    def get_liquidus_salinity(self, temperature):\n        return (\n            self.a0\n            + self.a1 * temperature\n            + self.a2 * temperature**2\n            + self.a3 * temperature**3\n        )\n\n    def get_liquidus_temperature(self, salinity):\n        temperature = fsolve(\n            lambda x: salinity - self.get_liquidus_salinity(x),\n            np.full_like(salinity, -2),\n        )\n        if temperature.size == 1:\n            return temperature[0]\n        else:\n            return temperature\n</code></pre>"},{"location":"#seaice3p.params.DimensionalBRW09OceanForcing","title":"<code>DimensionalBRW09OceanForcing</code>  <code>dataclass</code>","text":"<p>Ocean temperature provided by Barrow 2009 data at 2.4m and specify ocean fixed gas saturation state</p> Source code in <code>seaice3p/params/dimensional/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalBRW09OceanForcing:\n    \"\"\"Ocean temperature provided by Barrow 2009 data at 2.4m and specify ocean\n    fixed gas saturation state\"\"\"\n\n    pass\n</code></pre>"},{"location":"#seaice3p.params.DimensionalConstantTurbulentFlux","title":"<code>DimensionalConstantTurbulentFlux</code>  <code>dataclass</code>","text":"<p>Parameters for calculating the turbulent surface sensible and latent heat fluxes</p> <p>NOTE: If you are running a simulation with ERA5 reanalysis forcing you must set the ref_height=2m as this is the appropriate value for the atmospheric reanalysis quantities</p> Source code in <code>seaice3p/params/dimensional/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalConstantTurbulentFlux:\n    \"\"\"Parameters for calculating the turbulent surface sensible and latent heat\n    fluxes\n\n    NOTE: If you are running a simulation with ERA5 reanalysis forcing you must set\n    the ref_height=2m as this is the appropriate value for the atmospheric reanalysis\n    quantities\n    \"\"\"\n\n    ref_height: float = 10  # m\n    windspeed: float = 5  # m/s\n    air_temp: float = 0  # deg C\n    specific_humidity: float = 3.6e-3  # kg water / kg air\n    atm_pressure: float = 101.325  # KPa\n\n    air_density: float = 1.275  # kg/m3\n    air_heat_capacity: float = 1005  # J/kg K\n    air_latent_heat_of_vaporisation: float = 2.501e6  # J/kg\n</code></pre>"},{"location":"#seaice3p.params.DimensionalERA5Forcing","title":"<code>DimensionalERA5Forcing</code>","text":"<p>read ERA5 data from netCDF file located at data_path.</p> <p>Simulation will take atmospheric forcings from the start date specified in the format YYYY-MM-DD</p> Source code in <code>seaice3p/params/dimensional/forcing.py</code> <pre><code>@serde(type_check=coerce)\nclass DimensionalERA5Forcing:\n    \"\"\"read ERA5 data from netCDF file located at data_path.\n\n    Simulation will take atmospheric forcings from the start date specified in the\n    format YYYY-MM-DD\n    \"\"\"\n\n    data_path: Path\n    start_date: str  # YYYY-MM-DD\n    use_snow_data: bool = False\n    SW_forcing: DimensionalSWForcing = DimensionalConstantSWForcing()\n    LW_forcing: DimensionalLWForcing = DimensionalConstantLWForcing()\n    turbulent_flux: DimensionalTurbulentFlux = DimensionalConstantTurbulentFlux()\n    oil_heating: DimensionalOilHeating = DimensionalBackgroundOilHeating()\n</code></pre>"},{"location":"#seaice3p.params.DimensionalFixedHeatFluxOceanForcing","title":"<code>DimensionalFixedHeatFluxOceanForcing</code>  <code>dataclass</code>","text":"<p>Provides constant ocean heat flux at the bottom of the domain</p> <p>Parameters:</p> Name Type Description Default <code>ocean_heat_flux</code> <code>float</code> <p>The constant heat flux at the bottom of the domain in W/m2</p> <code>1</code> Source code in <code>seaice3p/params/dimensional/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalFixedHeatFluxOceanForcing:\n    \"\"\"Provides constant ocean heat flux at the bottom of the domain\n\n    Args:\n        ocean_heat_flux: The constant heat flux at the bottom of the domain in W/m2\n    \"\"\"\n\n    ocean_heat_flux: float = 1\n</code></pre>"},{"location":"#seaice3p.params.DimensionalFixedTempOceanForcing","title":"<code>DimensionalFixedTempOceanForcing</code>  <code>dataclass</code>","text":"<p>Fixed temperature and gas saturation ocean boundary condition</p> Source code in <code>seaice3p/params/dimensional/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalFixedTempOceanForcing:\n    \"\"\"Fixed temperature and gas saturation ocean boundary condition\"\"\"\n\n    ocean_temp: float = -1\n</code></pre>"},{"location":"#seaice3p.params.DimensionalMonoBubbleParams","title":"<code>DimensionalMonoBubbleParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DimensionalBaseBubbleParams</code></p> Source code in <code>seaice3p/params/dimensional/bubble.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalMonoBubbleParams(DimensionalBaseBubbleParams):\n    bubble_radius: float = 1e-3  # bubble radius in m\n\n    @property\n    def bubble_radius_scaled(self):\n        r\"\"\"calculate the bubble radius divided by the pore scale\n\n        .. math:: \\Lambda = R_B / R_0\n\n        \"\"\"\n        return self.bubble_radius / self.pore_radius\n</code></pre>"},{"location":"#seaice3p.params.DimensionalMonoBubbleParams.bubble_radius_scaled","title":"<code>bubble_radius_scaled</code>  <code>property</code>","text":"<p>calculate the bubble radius divided by the pore scale</p> <p>.. math:: \\Lambda = R_B / R_0</p>"},{"location":"#seaice3p.params.DimensionalParams","title":"<code>DimensionalParams</code>  <code>dataclass</code>","text":"<p>Contains all dimensional parameters needed to calculate non dimensional numbers.</p> <p>To see the units each input should have look at the comment next to the default value.</p> Source code in <code>seaice3p/params/dimensional/dimensional.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalParams:\n    \"\"\"Contains all dimensional parameters needed to calculate non dimensional numbers.\n\n    To see the units each input should have look at the comment next to the default\n    value.\n    \"\"\"\n\n    name: str\n    total_time_in_days: float\n    savefreq_in_days: float\n    lengthscale: float\n\n    gas_params: DimensionalEQMGasParams | DimensionalDISEQGasParams\n    bubble_params: DimensionalMonoBubbleParams | DimensionalPowerLawBubbleParams\n    brine_convection_params: DimensionalRJW14Params | NoBrineConvection\n    forcing_config: DimensionalRadForcing | DimensionalBRW09Forcing | DimensionalConstantForcing | DimensionalYearlyForcing | DimensionalRobinForcing | DimensionalERA5Forcing\n    ocean_forcing_config: DimensionalBRW09OceanForcing | DimensionalFixedTempOceanForcing | DimensionalFixedHeatFluxOceanForcing\n    initial_conditions_config: DimensionalOilInitialConditions | UniformInitialConditions | BRW09InitialConditions | PreviousSimulation\n\n    water_params: DimensionalWaterParams = DimensionalWaterParams()\n    numerical_params: NumericalParams = NumericalParams()\n    frame_velocity_dimensional: float = 0  # velocity of frame in m/day\n    gravity: float = 9.81  # m/s2\n\n    @property\n    def damkohler_number(self):\n        r\"\"\"Return damkohler number as ratio of thermal timescale to nucleation\n        timescale\n        \"\"\"\n        if isinstance(self.gas_params, DimensionalEQMGasParams):\n            return None\n\n        return (\n            (self.lengthscale**2) / self.water_params.thermal_diffusivity\n        ) / self.gas_params.nucleation_timescale\n\n    @property\n    def total_time(self):\n        \"\"\"calculate the total time in non dimensional units for the simulation\"\"\"\n        return self.total_time_in_days / self.scales.time_scale\n\n    @property\n    def savefreq(self):\n        \"\"\"calculate the save frequency in non dimensional time\"\"\"\n        return self.savefreq_in_days / self.scales.time_scale\n\n    @property\n    def frame_velocity(self):\n        \"\"\"calculate the frame velocity in non dimensional units\"\"\"\n        return self.frame_velocity_dimensional / self.scales.velocity_scale\n\n    @property\n    def B(self):\n        r\"\"\"calculate the non dimensional scale for buoyant rise of gas bubbles as\n\n        .. math:: \\mathcal{B} = \\frac{\\rho_l g R_0^2 h}{3 \\mu \\kappa}\n\n        \"\"\"\n        stokes_velocity = (\n            (self.water_params.liquid_density - self.gas_params.gas_density)\n            * self.gravity\n            * self.bubble_params.pore_radius**2\n            / (3 * self.water_params.liquid_viscosity)\n        )\n        velocity_scale_in_m_per_second = (\n            self.water_params.thermal_diffusivity / self.lengthscale\n        )\n        return stokes_velocity / velocity_scale_in_m_per_second\n\n    @property\n    def Rayleigh_salt(self):\n        r\"\"\"Calculate the haline Rayleigh number as\n\n        .. math:: \\text{Ra}_S = \\frac{\\rho_l g \\beta \\Delta S H K_0}{\\kappa \\mu}\n\n        \"\"\"\n        match self.brine_convection_params:\n            case DimensionalRJW14Params():\n                return (\n                    self.water_params.liquid_density\n                    * self.gravity\n                    * self.water_params.haline_contraction_coefficient\n                    * self.water_params.salinity_difference\n                    * self.lengthscale\n                    * self.brine_convection_params.reference_permeability\n                    / (\n                        self.water_params.thermal_diffusivity\n                        * self.water_params.liquid_viscosity\n                    )\n                )\n            case NoBrineConvection():\n                return None\n\n    @property\n    def expansion_coefficient(self):\n        r\"\"\"calculate\n\n        .. math:: \\chi = \\rho_l \\xi_{\\text{sat}} / \\rho_g\n\n        \"\"\"\n        return (\n            self.water_params.liquid_density\n            * self.gas_params.saturation_concentration\n            / self.gas_params.gas_density\n        )\n\n    @property\n    def lewis_gas(self):\n        r\"\"\"Calculate the lewis number for dissolved gas, return np.inf if there is no\n        dissolved gas diffusion.\n\n        .. math:: \\text{Le}_\\xi = \\kappa / D_\\xi\n\n        \"\"\"\n        if self.gas_params.gas_diffusivity == 0:\n            return np.inf\n\n        return self.water_params.thermal_diffusivity / self.gas_params.gas_diffusivity\n\n    @property\n    def scales(self):\n        \"\"\"return a Scales object used for converting between dimensional and non\n        dimensional variables.\"\"\"\n        return Scales(\n            self.lengthscale,\n            self.water_params.thermal_diffusivity,\n            self.water_params.liquid_thermal_conductivity,\n            self.water_params.ocean_salinity,\n            self.water_params.salinity_difference,\n            self.water_params.ocean_freezing_temperature,\n            self.water_params.temperature_difference,\n            self.gas_params.gas_density,\n            self.water_params.liquid_density,\n            self.water_params.ice_density,\n            self.gas_params.saturation_concentration,\n            self.bubble_params.pore_radius,\n            self.water_params.haline_contraction_coefficient,\n        )\n\n    def save(self, directory: Path):\n        \"\"\"save this object to a yaml file in the specified directory.\n\n        The name will be the name given with _dimensional appended to distinguish it\n        from a saved non-dimensional configuration.\"\"\"\n        with open(directory / f\"{self.name}_dimensional.yml\", \"w\") as outfile:\n            outfile.write(to_yaml(self))\n\n    @classmethod\n    def load(cls, path):\n        \"\"\"load this object from a yaml configuration file.\"\"\"\n        with open(path, \"r\") as infile:\n            yaml = infile.read()\n        return from_yaml(cls, yaml)\n</code></pre>"},{"location":"#seaice3p.params.DimensionalParams.B","title":"<code>B</code>  <code>property</code>","text":"<p>calculate the non dimensional scale for buoyant rise of gas bubbles as</p> <p>.. math:: \\mathcal{B} = \\frac{\\rho_l g R_0^2 h}{3 \\mu \\kappa}</p>"},{"location":"#seaice3p.params.DimensionalParams.Rayleigh_salt","title":"<code>Rayleigh_salt</code>  <code>property</code>","text":"<p>Calculate the haline Rayleigh number as</p> <p>.. math:: \\text{Ra}_S = \\frac{\\rho_l g \\beta \\Delta S H K_0}{\\kappa \\mu}</p>"},{"location":"#seaice3p.params.DimensionalParams.damkohler_number","title":"<code>damkohler_number</code>  <code>property</code>","text":"<p>Return damkohler number as ratio of thermal timescale to nucleation timescale</p>"},{"location":"#seaice3p.params.DimensionalParams.expansion_coefficient","title":"<code>expansion_coefficient</code>  <code>property</code>","text":"<p>calculate</p> <p>.. math:: \\chi = \\rho_l \\xi_{\\text{sat}} / \\rho_g</p>"},{"location":"#seaice3p.params.DimensionalParams.frame_velocity","title":"<code>frame_velocity</code>  <code>property</code>","text":"<p>calculate the frame velocity in non dimensional units</p>"},{"location":"#seaice3p.params.DimensionalParams.lewis_gas","title":"<code>lewis_gas</code>  <code>property</code>","text":"<p>Calculate the lewis number for dissolved gas, return np.inf if there is no dissolved gas diffusion.</p> <p>.. math:: \\text{Le}\\xi = \\kappa / D\\xi</p>"},{"location":"#seaice3p.params.DimensionalParams.savefreq","title":"<code>savefreq</code>  <code>property</code>","text":"<p>calculate the save frequency in non dimensional time</p>"},{"location":"#seaice3p.params.DimensionalParams.scales","title":"<code>scales</code>  <code>property</code>","text":"<p>return a Scales object used for converting between dimensional and non dimensional variables.</p>"},{"location":"#seaice3p.params.DimensionalParams.total_time","title":"<code>total_time</code>  <code>property</code>","text":"<p>calculate the total time in non dimensional units for the simulation</p>"},{"location":"#seaice3p.params.DimensionalParams.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>load this object from a yaml configuration file.</p> Source code in <code>seaice3p/params/dimensional/dimensional.py</code> <pre><code>@classmethod\ndef load(cls, path):\n    \"\"\"load this object from a yaml configuration file.\"\"\"\n    with open(path, \"r\") as infile:\n        yaml = infile.read()\n    return from_yaml(cls, yaml)\n</code></pre>"},{"location":"#seaice3p.params.DimensionalParams.save","title":"<code>save(directory)</code>","text":"<p>save this object to a yaml file in the specified directory.</p> <p>The name will be the name given with _dimensional appended to distinguish it from a saved non-dimensional configuration.</p> Source code in <code>seaice3p/params/dimensional/dimensional.py</code> <pre><code>def save(self, directory: Path):\n    \"\"\"save this object to a yaml file in the specified directory.\n\n    The name will be the name given with _dimensional appended to distinguish it\n    from a saved non-dimensional configuration.\"\"\"\n    with open(directory / f\"{self.name}_dimensional.yml\", \"w\") as outfile:\n        outfile.write(to_yaml(self))\n</code></pre>"},{"location":"#seaice3p.params.DimensionalPowerLawBubbleParams","title":"<code>DimensionalPowerLawBubbleParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DimensionalBaseBubbleParams</code></p> Source code in <code>seaice3p/params/dimensional/bubble.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalPowerLawBubbleParams(DimensionalBaseBubbleParams):\n    bubble_distribution_power: float = 1.5\n    minimum_bubble_radius: float = 1e-6\n    maximum_bubble_radius: float = 1e-3\n\n    @property\n    def minimum_bubble_radius_scaled(self):\n        r\"\"\"calculate the bubble radius divided by the pore scale\n\n        .. math:: \\Lambda = R_B / R_0\n\n        \"\"\"\n        return self.minimum_bubble_radius / self.pore_radius\n\n    @property\n    def maximum_bubble_radius_scaled(self):\n        r\"\"\"calculate the bubble radius divided by the pore scale\n\n        .. math:: \\Lambda = R_B / R_0\n\n        \"\"\"\n        return self.maximum_bubble_radius / self.pore_radius\n</code></pre>"},{"location":"#seaice3p.params.DimensionalPowerLawBubbleParams.maximum_bubble_radius_scaled","title":"<code>maximum_bubble_radius_scaled</code>  <code>property</code>","text":"<p>calculate the bubble radius divided by the pore scale</p> <p>.. math:: \\Lambda = R_B / R_0</p>"},{"location":"#seaice3p.params.DimensionalPowerLawBubbleParams.minimum_bubble_radius_scaled","title":"<code>minimum_bubble_radius_scaled</code>  <code>property</code>","text":"<p>calculate the bubble radius divided by the pore scale</p> <p>.. math:: \\Lambda = R_B / R_0</p>"},{"location":"#seaice3p.params.DimensionalRobinForcing","title":"<code>DimensionalRobinForcing</code>  <code>dataclass</code>","text":"<p>This forcing imposes a Robin boundary condition of the form surface_heat_flux=heat_transfer_coefficient * (restoring_temp - surface_temp)</p> Source code in <code>seaice3p/params/dimensional/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalRobinForcing:\n    \"\"\"This forcing imposes a Robin boundary condition of the form\n    surface_heat_flux=heat_transfer_coefficient * (restoring_temp - surface_temp)\n    \"\"\"\n\n    heat_transfer_coefficient: float = 6.3  # W/m2K\n    restoring_temperature: float = -30  # deg C\n</code></pre>"},{"location":"#seaice3p.params.DimensionalWaterParams","title":"<code>DimensionalWaterParams</code>  <code>dataclass</code>","text":"Source code in <code>seaice3p/params/dimensional/water.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalWaterParams:\n    liquid_density: float = 1028  # kg/m3\n    ice_density: float = 916  # kg/m3\n    ocean_salinity: float = 34  # g/kg\n    liquidus: LinearLiquidus | CubicLiquidus = LinearLiquidus()\n    latent_heat: float = 334e3  # latent heat of fusion for ice in J/kg\n    liquid_specific_heat_capacity: float = 4184  # J/kg degC\n    solid_specific_heat_capacity: float = 2009  # J/kg degC\n    liquid_thermal_conductivity: float = 0.54  # water thermal conductivity in W/m deg C\n    solid_thermal_conductivity: float = 2.22  # ice thermal conductivity in W/m deg C\n    snow_thermal_conductivity: float = 0.31  # snow thermal conductivity in W/m deg C\n    snow_density: float = 150  # snow density kg/m3\n\n    eddy_diffusivity: float = 0\n\n    salt_diffusivity: float = 0  # molecular diffusivity of salt in water in m2/s\n    # used to calculate Rayleigh number for convection and density contraction in liquid equation of state\n    haline_contraction_coefficient: float = 7.5e-4  # 1/ppt\n\n    # calculated from moreau et al 2014 value of kinematic viscosity for sewater 2.7e-6\n    # dynamic liquid_viscosity = 2.7e-6 * liquid_density\n    liquid_viscosity: float = 2.78e-3  # dynamic liquid viscosity in Pa.s\n\n    @property\n    def eutectic_salinity(self):\n        if isinstance(self.liquidus, LinearLiquidus):\n            return self.liquidus.eutectic_salinity\n        if isinstance(self.liquidus, CubicLiquidus):\n            return self.liquidus.get_liquidus_salinity(\n                self.liquidus.eutectic_temperature\n            )\n\n        raise NotImplementedError\n\n    @property\n    def eutectic_temperature(self):\n        if isinstance(self.liquidus, LinearLiquidus) or isinstance(\n            self.liquidus, CubicLiquidus\n        ):\n            return self.liquidus.eutectic_temperature\n\n        raise NotImplementedError\n\n    @property\n    def salinity_difference(self):\n        r\"\"\"calculate difference between eutectic salinity and typical ocean salinity\n\n        .. math:: \\Delta S = S_E - S_i\n\n        \"\"\"\n        return self.eutectic_salinity - self.ocean_salinity\n\n    @property\n    def ocean_freezing_temperature(self):\n        \"\"\"calculate salinity dependent freezing temperature using linear liquidus with\n        ocean salinity\n\n        .. math:: T_i = T_L(S_i) = T_E S_i / S_E\n\n        or using a cubic fit for the liquidus curve\n\n        \"\"\"\n        if isinstance(self.liquidus, LinearLiquidus):\n            return (\n                self.eutectic_temperature * self.ocean_salinity / self.eutectic_salinity\n            )\n        if isinstance(self.liquidus, CubicLiquidus):\n            return self.liquidus.get_liquidus_temperature(self.ocean_salinity)\n\n        raise NotImplementedError\n\n    @property\n    def temperature_difference(self):\n        r\"\"\"calculate\n\n        .. math:: \\Delta T = T_i - T_E\n\n        \"\"\"\n        return self.ocean_freezing_temperature - self.eutectic_temperature\n\n    @property\n    def concentration_ratio(self):\n        r\"\"\"Calculate concentration ratio as\n\n        .. math:: \\mathcal{C} = S_i / \\Delta S\n\n        \"\"\"\n        return self.ocean_salinity / self.salinity_difference\n\n    @property\n    def stefan_number(self):\n        r\"\"\"calculate Stefan number\n\n        .. math:: \\text{St} = L / c_p \\Delta T\n\n        \"\"\"\n        return self.latent_heat / (\n            self.temperature_difference * self.liquid_specific_heat_capacity\n        )\n\n    @property\n    def thermal_diffusivity(self):\n        r\"\"\"Return thermal diffusivity in m2/s\n\n        .. math:: \\kappa = \\frac{k}{\\rho_l c_p}\n\n        \"\"\"\n        return self.liquid_thermal_conductivity / (\n            self.liquid_density * self.liquid_specific_heat_capacity\n        )\n\n    @property\n    def conductivity_ratio(self):\n        r\"\"\"Calculate the ratio of solid to liquid thermal conductivity\n\n        .. math:: \\lambda = \\frac{k_s}{k_l}\n\n        \"\"\"\n        return self.solid_thermal_conductivity / self.liquid_thermal_conductivity\n\n    @property\n    def specific_heat_ratio(self):\n        r\"\"\"Calculate the ratio of solid to liquid specific heat capacities\n\n        .. math:: \\lambda = \\frac{c_{p,s}}{c_{p,l}}\n\n        \"\"\"\n        return self.solid_specific_heat_capacity / self.liquid_specific_heat_capacity\n\n    @property\n    def eddy_diffusivity_ratio(self):\n        r\"\"\"Calculate the ratio of eddy diffusivity to thermal diffusivity in\n        the liquid phase\n\n        .. math:: \\lambda = \\frac{\\kappa_\\text{turbulent}}{\\kappa_l}\n\n        \"\"\"\n        return self.eddy_diffusivity / self.thermal_diffusivity\n\n    @property\n    def snow_conductivity_ratio(self):\n        r\"\"\"Calculate the ratio of snow to liquid thermal conductivity\n\n        .. math:: \\lambda = \\frac{k_{sn}}{k_l}\n\n        \"\"\"\n        return self.snow_thermal_conductivity / self.liquid_thermal_conductivity\n\n    @property\n    def lewis_salt(self):\n        r\"\"\"Calculate the lewis number for salt, return np.inf if there is no salt\n        diffusion.\n\n        .. math:: \\text{Le}_S = \\kappa / D_s\n\n        \"\"\"\n        if self.salt_diffusivity == 0:\n            return np.inf\n\n        return self.thermal_diffusivity / self.salt_diffusivity\n</code></pre>"},{"location":"#seaice3p.params.DimensionalWaterParams.concentration_ratio","title":"<code>concentration_ratio</code>  <code>property</code>","text":"<p>Calculate concentration ratio as</p> <p>.. math:: \\mathcal{C} = S_i / \\Delta S</p>"},{"location":"#seaice3p.params.DimensionalWaterParams.conductivity_ratio","title":"<code>conductivity_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of solid to liquid thermal conductivity</p> <p>.. math:: \\lambda = \\frac{k_s}{k_l}</p>"},{"location":"#seaice3p.params.DimensionalWaterParams.eddy_diffusivity_ratio","title":"<code>eddy_diffusivity_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of eddy diffusivity to thermal diffusivity in the liquid phase</p> <p>.. math:: \\lambda = \\frac{\\kappa_\\text{turbulent}}{\\kappa_l}</p>"},{"location":"#seaice3p.params.DimensionalWaterParams.lewis_salt","title":"<code>lewis_salt</code>  <code>property</code>","text":"<p>Calculate the lewis number for salt, return np.inf if there is no salt diffusion.</p> <p>.. math:: \\text{Le}_S = \\kappa / D_s</p>"},{"location":"#seaice3p.params.DimensionalWaterParams.ocean_freezing_temperature","title":"<code>ocean_freezing_temperature</code>  <code>property</code>","text":"<p>calculate salinity dependent freezing temperature using linear liquidus with ocean salinity</p> <p>.. math:: T_i = T_L(S_i) = T_E S_i / S_E</p> <p>or using a cubic fit for the liquidus curve</p>"},{"location":"#seaice3p.params.DimensionalWaterParams.salinity_difference","title":"<code>salinity_difference</code>  <code>property</code>","text":"<p>calculate difference between eutectic salinity and typical ocean salinity</p> <p>.. math:: \\Delta S = S_E - S_i</p>"},{"location":"#seaice3p.params.DimensionalWaterParams.snow_conductivity_ratio","title":"<code>snow_conductivity_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of snow to liquid thermal conductivity</p> <p>.. math:: \\lambda = \\frac{k_{sn}}{k_l}</p>"},{"location":"#seaice3p.params.DimensionalWaterParams.specific_heat_ratio","title":"<code>specific_heat_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of solid to liquid specific heat capacities</p> <p>.. math:: \\lambda = \\frac{c_{p,s}}{c_{p,l}}</p>"},{"location":"#seaice3p.params.DimensionalWaterParams.stefan_number","title":"<code>stefan_number</code>  <code>property</code>","text":"<p>calculate Stefan number</p> <p>.. math:: \\text{St} = L / c_p \\Delta T</p>"},{"location":"#seaice3p.params.DimensionalWaterParams.temperature_difference","title":"<code>temperature_difference</code>  <code>property</code>","text":"<p>calculate</p> <p>.. math:: \\Delta T = T_i - T_E</p>"},{"location":"#seaice3p.params.DimensionalWaterParams.thermal_diffusivity","title":"<code>thermal_diffusivity</code>  <code>property</code>","text":"<p>Return thermal diffusivity in m2/s</p> <p>.. math:: \\kappa = \\frac{k}{\\rho_l c_p}</p>"},{"location":"#seaice3p.params.NoBrineConvection","title":"<code>NoBrineConvection</code>  <code>dataclass</code>","text":"<p>No brine convection</p> Source code in <code>seaice3p/params/dimensional/convection.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass NoBrineConvection:\n    \"\"\"No brine convection\"\"\"\n</code></pre>"},{"location":"#seaice3p.params.NumericalParams","title":"<code>NumericalParams</code>  <code>dataclass</code>","text":"<p>parameters needed for discretisation and choice of numerical method</p> Source code in <code>seaice3p/params/dimensional/numerical.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass NumericalParams:\n    \"\"\"parameters needed for discretisation and choice of numerical method\"\"\"\n\n    I: int = 50\n    regularisation: float = 1e-6\n    solver_choice: str = \"RK23\"  # scipy.integrate.solve_IVP solver choice\n\n    @property\n    def step(self):\n        return 1 / self.I\n</code></pre>"},{"location":"#seaice3p.params.UniformInitialConditions","title":"<code>UniformInitialConditions</code>  <code>dataclass</code>","text":"<p>values for bottom (ocean) boundary</p> Source code in <code>seaice3p/params/dimensional/initial_conditions.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass UniformInitialConditions:\n    \"\"\"values for bottom (ocean) boundary\"\"\"\n</code></pre>"},{"location":"#seaice3p.params.bubble","title":"<code>bubble</code>","text":""},{"location":"#seaice3p.params.bubble.BaseBubbleParams","title":"<code>BaseBubbleParams</code>  <code>dataclass</code>","text":"<p>Not to be used directly but provides parameters for bubble model in sea ice common to other bubble parameter objects.</p> Source code in <code>seaice3p/params/bubble.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass BaseBubbleParams:\n    \"\"\"Not to be used directly but provides parameters for bubble model in sea ice\n    common to other bubble parameter objects.\n    \"\"\"\n\n    B: float = 100\n    pore_throat_scaling: float = 0.46\n    porosity_threshold: bool = False\n    porosity_threshold_value: float = 0.024\n    escape_ice_surface: bool = True\n</code></pre>"},{"location":"#seaice3p.params.bubble.MonoBubbleParams","title":"<code>MonoBubbleParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBubbleParams</code></p> <p>Parameters for population of identical spherical bubbles.</p> Source code in <code>seaice3p/params/bubble.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass MonoBubbleParams(BaseBubbleParams):\n    \"\"\"Parameters for population of identical spherical bubbles.\"\"\"\n\n    bubble_radius_scaled: float = 1.0\n</code></pre>"},{"location":"#seaice3p.params.bubble.PowerLawBubbleParams","title":"<code>PowerLawBubbleParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BaseBubbleParams</code></p> <p>Parameters for population of bubbles following a power law size distribution between a minimum and maximum radius.</p> Source code in <code>seaice3p/params/bubble.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass PowerLawBubbleParams(BaseBubbleParams):\n    \"\"\"Parameters for population of bubbles following a power law size distribution\n    between a minimum and maximum radius.\n    \"\"\"\n\n    bubble_distribution_power: float = 1.5\n    minimum_bubble_radius_scaled: float = 1e-3\n    maximum_bubble_radius_scaled: float = 1\n</code></pre>"},{"location":"#seaice3p.params.convection","title":"<code>convection</code>","text":""},{"location":"#seaice3p.params.convection.RJW14Params","title":"<code>RJW14Params</code>  <code>dataclass</code>","text":"<p>Parameters for the RJW14 parameterisation of brine convection</p> Source code in <code>seaice3p/params/convection.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass RJW14Params:\n    \"\"\"Parameters for the RJW14 parameterisation of brine convection\"\"\"\n\n    Rayleigh_salt: float = 44105\n    Rayleigh_critical: float = 2.9\n    convection_strength: float = 0.13\n    couple_bubble_to_horizontal_flow: bool = False\n    couple_bubble_to_vertical_flow: bool = False\n    advective_heat_flux_in_ocean: bool = True\n</code></pre>"},{"location":"#seaice3p.params.convert","title":"<code>convert</code>","text":""},{"location":"#seaice3p.params.convert.Scales","title":"<code>Scales</code>  <code>dataclass</code>","text":"Source code in <code>seaice3p/params/convert.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass Scales:\n    lengthscale: float  # domain height in m\n    thermal_diffusivity: float  # m2/s\n    liquid_thermal_conductivity: float  # W/m deg C\n    ocean_salinity: float  # g/kg\n    salinity_difference: float  # g/kg\n    ocean_freezing_temperature: float  # deg C\n    temperature_difference: float  # deg C\n    gas_density: float  # kg/m3\n    liquid_density: float  # kg/m3\n    ice_density: float  # kg/m3\n    saturation_concentration: float  # kg(gas)/kg(liquid)\n    pore_radius: float  # m\n    haline_contraction_coefficient: float  # 1/ppt\n\n    @property\n    def time_scale(self):\n        \"\"\"in days\"\"\"\n        return SECONDS_TO_DAYS * self.lengthscale**2 / self.thermal_diffusivity\n\n    @property\n    def velocity_scale(self):\n        \"\"\"in m /day\"\"\"\n        return self.lengthscale / self.time_scale\n\n    def convert_from_dimensional_temperature(self, dimensional_temperature):\n        \"\"\"Non dimensionalise temperature in deg C\"\"\"\n        return (\n            dimensional_temperature - self.ocean_freezing_temperature\n        ) / self.temperature_difference\n\n    def convert_to_dimensional_temperature(self, temperature):\n        \"\"\"get temperature in deg C from non dimensional temperature\"\"\"\n        return (\n            self.temperature_difference * temperature + self.ocean_freezing_temperature\n        )\n\n    def convert_from_dimensional_grid(self, dimensional_grid):\n        \"\"\"Non dimensionalise domain depths in meters\"\"\"\n        return dimensional_grid / self.lengthscale\n\n    def convert_to_dimensional_grid(self, grid):\n        \"\"\"Get domain depths in meters from non dimensional values\"\"\"\n        return self.lengthscale * grid\n\n    def convert_from_dimensional_time(self, dimensional_time):\n        \"\"\"Non dimensionalise time in days\"\"\"\n        return dimensional_time / self.time_scale\n\n    def convert_to_dimensional_time(self, time):\n        \"\"\"Convert non dimensional time into time in days since start of simulation\"\"\"\n        return self.time_scale * time\n\n    def convert_from_dimensional_bulk_salinity(self, dimensional_bulk_salinity):\n        \"\"\"Non dimensionalise bulk salinity in g/kg\"\"\"\n        return (\n            dimensional_bulk_salinity - self.ocean_salinity\n        ) / self.salinity_difference\n\n    def convert_to_dimensional_bulk_salinity(self, bulk_salinity):\n        \"\"\"Convert non dimensional bulk salinity to g/kg\"\"\"\n        return self.salinity_difference * bulk_salinity + self.ocean_salinity\n\n    def convert_from_dimensional_bulk_gas(self, dimensional_bulk_gas):\n        \"\"\"Non dimensionalise bulk gas content in kg/m3\"\"\"\n        return dimensional_bulk_gas / self.gas_density\n\n    def convert_to_dimensional_bulk_gas(self, bulk_gas):\n        \"\"\"Convert dimensionless bulk gas content to kg/m3\"\"\"\n        return self.gas_density * bulk_gas\n\n    def convert_dimensional_bulk_air_to_argon_content(self, dimensional_bulk_gas):\n        \"\"\"Convert kg/m3 of air to micromole of Argon per Liter of ice\"\"\"\n        mass_ratio_of_argon_in_air = 0.01288\n        micromoles_of_argon_in_a_kilogram_of_argon = 1 / (3.9948e-8)\n        liters_in_a_meter_cubed = 1e3\n        return (\n            dimensional_bulk_gas\n            * mass_ratio_of_argon_in_air\n            * micromoles_of_argon_in_a_kilogram_of_argon\n            / liters_in_a_meter_cubed\n        )\n\n    def convert_from_dimensional_dissolved_gas(self, dimensional_dissolved_gas):\n        \"\"\"convert from dissolved gas in kg(gas)/kg(liquid) to dimensionless\"\"\"\n        return dimensional_dissolved_gas / self.saturation_concentration\n\n    def convert_to_dimensional_dissolved_gas(self, dissolved_gas):\n        \"\"\"convert from non dimensional dissolved gas to dimensional dissolved gas in\n        kg(gas)/kg(liquid)\"\"\"\n        return self.saturation_concentration * dissolved_gas\n\n    def convert_from_dimensional_heating(self, dimensional_heating):\n        \"\"\"convert from heating rate in W/m3 to dimensionless units\"\"\"\n        return (\n            dimensional_heating\n            * self.lengthscale**2\n            / (self.liquid_thermal_conductivity * self.temperature_difference)\n        )\n\n    def convert_from_dimensional_heat_flux(self, dimensional_heat_flux):\n        \"\"\"convert from heat flux in W/m2 to dimensionless units\"\"\"\n        return (\n            dimensional_heat_flux\n            * self.lengthscale\n            / (self.liquid_thermal_conductivity * self.temperature_difference)\n        )\n\n    def convert_to_dimensional_heat_flux(self, heat_flux):\n        \"\"\"convert from dimensionless heat flux to heat flux in W/m2\"\"\"\n        return (\n            heat_flux\n            * (self.liquid_thermal_conductivity * self.temperature_difference)\n            / self.lengthscale\n        )\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.time_scale","title":"<code>time_scale</code>  <code>property</code>","text":"<p>in days</p>"},{"location":"#seaice3p.params.convert.Scales.velocity_scale","title":"<code>velocity_scale</code>  <code>property</code>","text":"<p>in m /day</p>"},{"location":"#seaice3p.params.convert.Scales.convert_dimensional_bulk_air_to_argon_content","title":"<code>convert_dimensional_bulk_air_to_argon_content(dimensional_bulk_gas)</code>","text":"<p>Convert kg/m3 of air to micromole of Argon per Liter of ice</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_dimensional_bulk_air_to_argon_content(self, dimensional_bulk_gas):\n    \"\"\"Convert kg/m3 of air to micromole of Argon per Liter of ice\"\"\"\n    mass_ratio_of_argon_in_air = 0.01288\n    micromoles_of_argon_in_a_kilogram_of_argon = 1 / (3.9948e-8)\n    liters_in_a_meter_cubed = 1e3\n    return (\n        dimensional_bulk_gas\n        * mass_ratio_of_argon_in_air\n        * micromoles_of_argon_in_a_kilogram_of_argon\n        / liters_in_a_meter_cubed\n    )\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_from_dimensional_bulk_gas","title":"<code>convert_from_dimensional_bulk_gas(dimensional_bulk_gas)</code>","text":"<p>Non dimensionalise bulk gas content in kg/m3</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_bulk_gas(self, dimensional_bulk_gas):\n    \"\"\"Non dimensionalise bulk gas content in kg/m3\"\"\"\n    return dimensional_bulk_gas / self.gas_density\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_from_dimensional_bulk_salinity","title":"<code>convert_from_dimensional_bulk_salinity(dimensional_bulk_salinity)</code>","text":"<p>Non dimensionalise bulk salinity in g/kg</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_bulk_salinity(self, dimensional_bulk_salinity):\n    \"\"\"Non dimensionalise bulk salinity in g/kg\"\"\"\n    return (\n        dimensional_bulk_salinity - self.ocean_salinity\n    ) / self.salinity_difference\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_from_dimensional_dissolved_gas","title":"<code>convert_from_dimensional_dissolved_gas(dimensional_dissolved_gas)</code>","text":"<p>convert from dissolved gas in kg(gas)/kg(liquid) to dimensionless</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_dissolved_gas(self, dimensional_dissolved_gas):\n    \"\"\"convert from dissolved gas in kg(gas)/kg(liquid) to dimensionless\"\"\"\n    return dimensional_dissolved_gas / self.saturation_concentration\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_from_dimensional_grid","title":"<code>convert_from_dimensional_grid(dimensional_grid)</code>","text":"<p>Non dimensionalise domain depths in meters</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_grid(self, dimensional_grid):\n    \"\"\"Non dimensionalise domain depths in meters\"\"\"\n    return dimensional_grid / self.lengthscale\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_from_dimensional_heat_flux","title":"<code>convert_from_dimensional_heat_flux(dimensional_heat_flux)</code>","text":"<p>convert from heat flux in W/m2 to dimensionless units</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_heat_flux(self, dimensional_heat_flux):\n    \"\"\"convert from heat flux in W/m2 to dimensionless units\"\"\"\n    return (\n        dimensional_heat_flux\n        * self.lengthscale\n        / (self.liquid_thermal_conductivity * self.temperature_difference)\n    )\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_from_dimensional_heating","title":"<code>convert_from_dimensional_heating(dimensional_heating)</code>","text":"<p>convert from heating rate in W/m3 to dimensionless units</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_heating(self, dimensional_heating):\n    \"\"\"convert from heating rate in W/m3 to dimensionless units\"\"\"\n    return (\n        dimensional_heating\n        * self.lengthscale**2\n        / (self.liquid_thermal_conductivity * self.temperature_difference)\n    )\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_from_dimensional_temperature","title":"<code>convert_from_dimensional_temperature(dimensional_temperature)</code>","text":"<p>Non dimensionalise temperature in deg C</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_temperature(self, dimensional_temperature):\n    \"\"\"Non dimensionalise temperature in deg C\"\"\"\n    return (\n        dimensional_temperature - self.ocean_freezing_temperature\n    ) / self.temperature_difference\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_from_dimensional_time","title":"<code>convert_from_dimensional_time(dimensional_time)</code>","text":"<p>Non dimensionalise time in days</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_from_dimensional_time(self, dimensional_time):\n    \"\"\"Non dimensionalise time in days\"\"\"\n    return dimensional_time / self.time_scale\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_to_dimensional_bulk_gas","title":"<code>convert_to_dimensional_bulk_gas(bulk_gas)</code>","text":"<p>Convert dimensionless bulk gas content to kg/m3</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_bulk_gas(self, bulk_gas):\n    \"\"\"Convert dimensionless bulk gas content to kg/m3\"\"\"\n    return self.gas_density * bulk_gas\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_to_dimensional_bulk_salinity","title":"<code>convert_to_dimensional_bulk_salinity(bulk_salinity)</code>","text":"<p>Convert non dimensional bulk salinity to g/kg</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_bulk_salinity(self, bulk_salinity):\n    \"\"\"Convert non dimensional bulk salinity to g/kg\"\"\"\n    return self.salinity_difference * bulk_salinity + self.ocean_salinity\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_to_dimensional_dissolved_gas","title":"<code>convert_to_dimensional_dissolved_gas(dissolved_gas)</code>","text":"<p>convert from non dimensional dissolved gas to dimensional dissolved gas in kg(gas)/kg(liquid)</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_dissolved_gas(self, dissolved_gas):\n    \"\"\"convert from non dimensional dissolved gas to dimensional dissolved gas in\n    kg(gas)/kg(liquid)\"\"\"\n    return self.saturation_concentration * dissolved_gas\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_to_dimensional_grid","title":"<code>convert_to_dimensional_grid(grid)</code>","text":"<p>Get domain depths in meters from non dimensional values</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_grid(self, grid):\n    \"\"\"Get domain depths in meters from non dimensional values\"\"\"\n    return self.lengthscale * grid\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_to_dimensional_heat_flux","title":"<code>convert_to_dimensional_heat_flux(heat_flux)</code>","text":"<p>convert from dimensionless heat flux to heat flux in W/m2</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_heat_flux(self, heat_flux):\n    \"\"\"convert from dimensionless heat flux to heat flux in W/m2\"\"\"\n    return (\n        heat_flux\n        * (self.liquid_thermal_conductivity * self.temperature_difference)\n        / self.lengthscale\n    )\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_to_dimensional_temperature","title":"<code>convert_to_dimensional_temperature(temperature)</code>","text":"<p>get temperature in deg C from non dimensional temperature</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_temperature(self, temperature):\n    \"\"\"get temperature in deg C from non dimensional temperature\"\"\"\n    return (\n        self.temperature_difference * temperature + self.ocean_freezing_temperature\n    )\n</code></pre>"},{"location":"#seaice3p.params.convert.Scales.convert_to_dimensional_time","title":"<code>convert_to_dimensional_time(time)</code>","text":"<p>Convert non dimensional time into time in days since start of simulation</p> Source code in <code>seaice3p/params/convert.py</code> <pre><code>def convert_to_dimensional_time(self, time):\n    \"\"\"Convert non dimensional time into time in days since start of simulation\"\"\"\n    return self.time_scale * time\n</code></pre>"},{"location":"#seaice3p.params.dimensional","title":"<code>dimensional</code>","text":""},{"location":"#seaice3p.params.dimensional.bubble","title":"<code>bubble</code>","text":""},{"location":"#seaice3p.params.dimensional.bubble.DimensionalMonoBubbleParams","title":"<code>DimensionalMonoBubbleParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DimensionalBaseBubbleParams</code></p> Source code in <code>seaice3p/params/dimensional/bubble.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalMonoBubbleParams(DimensionalBaseBubbleParams):\n    bubble_radius: float = 1e-3  # bubble radius in m\n\n    @property\n    def bubble_radius_scaled(self):\n        r\"\"\"calculate the bubble radius divided by the pore scale\n\n        .. math:: \\Lambda = R_B / R_0\n\n        \"\"\"\n        return self.bubble_radius / self.pore_radius\n</code></pre>"},{"location":"#seaice3p.params.dimensional.bubble.DimensionalMonoBubbleParams.bubble_radius_scaled","title":"<code>bubble_radius_scaled</code>  <code>property</code>","text":"<p>calculate the bubble radius divided by the pore scale</p> <p>.. math:: \\Lambda = R_B / R_0</p>"},{"location":"#seaice3p.params.dimensional.bubble.DimensionalPowerLawBubbleParams","title":"<code>DimensionalPowerLawBubbleParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>DimensionalBaseBubbleParams</code></p> Source code in <code>seaice3p/params/dimensional/bubble.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalPowerLawBubbleParams(DimensionalBaseBubbleParams):\n    bubble_distribution_power: float = 1.5\n    minimum_bubble_radius: float = 1e-6\n    maximum_bubble_radius: float = 1e-3\n\n    @property\n    def minimum_bubble_radius_scaled(self):\n        r\"\"\"calculate the bubble radius divided by the pore scale\n\n        .. math:: \\Lambda = R_B / R_0\n\n        \"\"\"\n        return self.minimum_bubble_radius / self.pore_radius\n\n    @property\n    def maximum_bubble_radius_scaled(self):\n        r\"\"\"calculate the bubble radius divided by the pore scale\n\n        .. math:: \\Lambda = R_B / R_0\n\n        \"\"\"\n        return self.maximum_bubble_radius / self.pore_radius\n</code></pre>"},{"location":"#seaice3p.params.dimensional.bubble.DimensionalPowerLawBubbleParams.maximum_bubble_radius_scaled","title":"<code>maximum_bubble_radius_scaled</code>  <code>property</code>","text":"<p>calculate the bubble radius divided by the pore scale</p> <p>.. math:: \\Lambda = R_B / R_0</p>"},{"location":"#seaice3p.params.dimensional.bubble.DimensionalPowerLawBubbleParams.minimum_bubble_radius_scaled","title":"<code>minimum_bubble_radius_scaled</code>  <code>property</code>","text":"<p>calculate the bubble radius divided by the pore scale</p> <p>.. math:: \\Lambda = R_B / R_0</p>"},{"location":"#seaice3p.params.dimensional.convection","title":"<code>convection</code>","text":""},{"location":"#seaice3p.params.dimensional.convection.NoBrineConvection","title":"<code>NoBrineConvection</code>  <code>dataclass</code>","text":"<p>No brine convection</p> Source code in <code>seaice3p/params/dimensional/convection.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass NoBrineConvection:\n    \"\"\"No brine convection\"\"\"\n</code></pre>"},{"location":"#seaice3p.params.dimensional.dimensional","title":"<code>dimensional</code>","text":"<p>Dimensional parameters required to run a simulation and convert output to dimensional variables.</p> <p>The DimensionalParams class contains all the dimensional parameters needed to produce a simulation configuration.</p> <p>The Scales class contains all the dimensional parameters required to convert simulation output between physical and non-dimensional variables.</p>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams","title":"<code>DimensionalParams</code>  <code>dataclass</code>","text":"<p>Contains all dimensional parameters needed to calculate non dimensional numbers.</p> <p>To see the units each input should have look at the comment next to the default value.</p> Source code in <code>seaice3p/params/dimensional/dimensional.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalParams:\n    \"\"\"Contains all dimensional parameters needed to calculate non dimensional numbers.\n\n    To see the units each input should have look at the comment next to the default\n    value.\n    \"\"\"\n\n    name: str\n    total_time_in_days: float\n    savefreq_in_days: float\n    lengthscale: float\n\n    gas_params: DimensionalEQMGasParams | DimensionalDISEQGasParams\n    bubble_params: DimensionalMonoBubbleParams | DimensionalPowerLawBubbleParams\n    brine_convection_params: DimensionalRJW14Params | NoBrineConvection\n    forcing_config: DimensionalRadForcing | DimensionalBRW09Forcing | DimensionalConstantForcing | DimensionalYearlyForcing | DimensionalRobinForcing | DimensionalERA5Forcing\n    ocean_forcing_config: DimensionalBRW09OceanForcing | DimensionalFixedTempOceanForcing | DimensionalFixedHeatFluxOceanForcing\n    initial_conditions_config: DimensionalOilInitialConditions | UniformInitialConditions | BRW09InitialConditions | PreviousSimulation\n\n    water_params: DimensionalWaterParams = DimensionalWaterParams()\n    numerical_params: NumericalParams = NumericalParams()\n    frame_velocity_dimensional: float = 0  # velocity of frame in m/day\n    gravity: float = 9.81  # m/s2\n\n    @property\n    def damkohler_number(self):\n        r\"\"\"Return damkohler number as ratio of thermal timescale to nucleation\n        timescale\n        \"\"\"\n        if isinstance(self.gas_params, DimensionalEQMGasParams):\n            return None\n\n        return (\n            (self.lengthscale**2) / self.water_params.thermal_diffusivity\n        ) / self.gas_params.nucleation_timescale\n\n    @property\n    def total_time(self):\n        \"\"\"calculate the total time in non dimensional units for the simulation\"\"\"\n        return self.total_time_in_days / self.scales.time_scale\n\n    @property\n    def savefreq(self):\n        \"\"\"calculate the save frequency in non dimensional time\"\"\"\n        return self.savefreq_in_days / self.scales.time_scale\n\n    @property\n    def frame_velocity(self):\n        \"\"\"calculate the frame velocity in non dimensional units\"\"\"\n        return self.frame_velocity_dimensional / self.scales.velocity_scale\n\n    @property\n    def B(self):\n        r\"\"\"calculate the non dimensional scale for buoyant rise of gas bubbles as\n\n        .. math:: \\mathcal{B} = \\frac{\\rho_l g R_0^2 h}{3 \\mu \\kappa}\n\n        \"\"\"\n        stokes_velocity = (\n            (self.water_params.liquid_density - self.gas_params.gas_density)\n            * self.gravity\n            * self.bubble_params.pore_radius**2\n            / (3 * self.water_params.liquid_viscosity)\n        )\n        velocity_scale_in_m_per_second = (\n            self.water_params.thermal_diffusivity / self.lengthscale\n        )\n        return stokes_velocity / velocity_scale_in_m_per_second\n\n    @property\n    def Rayleigh_salt(self):\n        r\"\"\"Calculate the haline Rayleigh number as\n\n        .. math:: \\text{Ra}_S = \\frac{\\rho_l g \\beta \\Delta S H K_0}{\\kappa \\mu}\n\n        \"\"\"\n        match self.brine_convection_params:\n            case DimensionalRJW14Params():\n                return (\n                    self.water_params.liquid_density\n                    * self.gravity\n                    * self.water_params.haline_contraction_coefficient\n                    * self.water_params.salinity_difference\n                    * self.lengthscale\n                    * self.brine_convection_params.reference_permeability\n                    / (\n                        self.water_params.thermal_diffusivity\n                        * self.water_params.liquid_viscosity\n                    )\n                )\n            case NoBrineConvection():\n                return None\n\n    @property\n    def expansion_coefficient(self):\n        r\"\"\"calculate\n\n        .. math:: \\chi = \\rho_l \\xi_{\\text{sat}} / \\rho_g\n\n        \"\"\"\n        return (\n            self.water_params.liquid_density\n            * self.gas_params.saturation_concentration\n            / self.gas_params.gas_density\n        )\n\n    @property\n    def lewis_gas(self):\n        r\"\"\"Calculate the lewis number for dissolved gas, return np.inf if there is no\n        dissolved gas diffusion.\n\n        .. math:: \\text{Le}_\\xi = \\kappa / D_\\xi\n\n        \"\"\"\n        if self.gas_params.gas_diffusivity == 0:\n            return np.inf\n\n        return self.water_params.thermal_diffusivity / self.gas_params.gas_diffusivity\n\n    @property\n    def scales(self):\n        \"\"\"return a Scales object used for converting between dimensional and non\n        dimensional variables.\"\"\"\n        return Scales(\n            self.lengthscale,\n            self.water_params.thermal_diffusivity,\n            self.water_params.liquid_thermal_conductivity,\n            self.water_params.ocean_salinity,\n            self.water_params.salinity_difference,\n            self.water_params.ocean_freezing_temperature,\n            self.water_params.temperature_difference,\n            self.gas_params.gas_density,\n            self.water_params.liquid_density,\n            self.water_params.ice_density,\n            self.gas_params.saturation_concentration,\n            self.bubble_params.pore_radius,\n            self.water_params.haline_contraction_coefficient,\n        )\n\n    def save(self, directory: Path):\n        \"\"\"save this object to a yaml file in the specified directory.\n\n        The name will be the name given with _dimensional appended to distinguish it\n        from a saved non-dimensional configuration.\"\"\"\n        with open(directory / f\"{self.name}_dimensional.yml\", \"w\") as outfile:\n            outfile.write(to_yaml(self))\n\n    @classmethod\n    def load(cls, path):\n        \"\"\"load this object from a yaml configuration file.\"\"\"\n        with open(path, \"r\") as infile:\n            yaml = infile.read()\n        return from_yaml(cls, yaml)\n</code></pre>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams.B","title":"<code>B</code>  <code>property</code>","text":"<p>calculate the non dimensional scale for buoyant rise of gas bubbles as</p> <p>.. math:: \\mathcal{B} = \\frac{\\rho_l g R_0^2 h}{3 \\mu \\kappa}</p>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams.Rayleigh_salt","title":"<code>Rayleigh_salt</code>  <code>property</code>","text":"<p>Calculate the haline Rayleigh number as</p> <p>.. math:: \\text{Ra}_S = \\frac{\\rho_l g \\beta \\Delta S H K_0}{\\kappa \\mu}</p>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams.damkohler_number","title":"<code>damkohler_number</code>  <code>property</code>","text":"<p>Return damkohler number as ratio of thermal timescale to nucleation timescale</p>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams.expansion_coefficient","title":"<code>expansion_coefficient</code>  <code>property</code>","text":"<p>calculate</p> <p>.. math:: \\chi = \\rho_l \\xi_{\\text{sat}} / \\rho_g</p>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams.frame_velocity","title":"<code>frame_velocity</code>  <code>property</code>","text":"<p>calculate the frame velocity in non dimensional units</p>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams.lewis_gas","title":"<code>lewis_gas</code>  <code>property</code>","text":"<p>Calculate the lewis number for dissolved gas, return np.inf if there is no dissolved gas diffusion.</p> <p>.. math:: \\text{Le}\\xi = \\kappa / D\\xi</p>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams.savefreq","title":"<code>savefreq</code>  <code>property</code>","text":"<p>calculate the save frequency in non dimensional time</p>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams.scales","title":"<code>scales</code>  <code>property</code>","text":"<p>return a Scales object used for converting between dimensional and non dimensional variables.</p>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams.total_time","title":"<code>total_time</code>  <code>property</code>","text":"<p>calculate the total time in non dimensional units for the simulation</p>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams.load","title":"<code>load(path)</code>  <code>classmethod</code>","text":"<p>load this object from a yaml configuration file.</p> Source code in <code>seaice3p/params/dimensional/dimensional.py</code> <pre><code>@classmethod\ndef load(cls, path):\n    \"\"\"load this object from a yaml configuration file.\"\"\"\n    with open(path, \"r\") as infile:\n        yaml = infile.read()\n    return from_yaml(cls, yaml)\n</code></pre>"},{"location":"#seaice3p.params.dimensional.dimensional.DimensionalParams.save","title":"<code>save(directory)</code>","text":"<p>save this object to a yaml file in the specified directory.</p> <p>The name will be the name given with _dimensional appended to distinguish it from a saved non-dimensional configuration.</p> Source code in <code>seaice3p/params/dimensional/dimensional.py</code> <pre><code>def save(self, directory: Path):\n    \"\"\"save this object to a yaml file in the specified directory.\n\n    The name will be the name given with _dimensional appended to distinguish it\n    from a saved non-dimensional configuration.\"\"\"\n    with open(directory / f\"{self.name}_dimensional.yml\", \"w\") as outfile:\n        outfile.write(to_yaml(self))\n</code></pre>"},{"location":"#seaice3p.params.dimensional.forcing","title":"<code>forcing</code>","text":""},{"location":"#seaice3p.params.dimensional.forcing.DimensionalConstantTurbulentFlux","title":"<code>DimensionalConstantTurbulentFlux</code>  <code>dataclass</code>","text":"<p>Parameters for calculating the turbulent surface sensible and latent heat fluxes</p> <p>NOTE: If you are running a simulation with ERA5 reanalysis forcing you must set the ref_height=2m as this is the appropriate value for the atmospheric reanalysis quantities</p> Source code in <code>seaice3p/params/dimensional/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalConstantTurbulentFlux:\n    \"\"\"Parameters for calculating the turbulent surface sensible and latent heat\n    fluxes\n\n    NOTE: If you are running a simulation with ERA5 reanalysis forcing you must set\n    the ref_height=2m as this is the appropriate value for the atmospheric reanalysis\n    quantities\n    \"\"\"\n\n    ref_height: float = 10  # m\n    windspeed: float = 5  # m/s\n    air_temp: float = 0  # deg C\n    specific_humidity: float = 3.6e-3  # kg water / kg air\n    atm_pressure: float = 101.325  # KPa\n\n    air_density: float = 1.275  # kg/m3\n    air_heat_capacity: float = 1005  # J/kg K\n    air_latent_heat_of_vaporisation: float = 2.501e6  # J/kg\n</code></pre>"},{"location":"#seaice3p.params.dimensional.forcing.DimensionalERA5Forcing","title":"<code>DimensionalERA5Forcing</code>","text":"<p>read ERA5 data from netCDF file located at data_path.</p> <p>Simulation will take atmospheric forcings from the start date specified in the format YYYY-MM-DD</p> Source code in <code>seaice3p/params/dimensional/forcing.py</code> <pre><code>@serde(type_check=coerce)\nclass DimensionalERA5Forcing:\n    \"\"\"read ERA5 data from netCDF file located at data_path.\n\n    Simulation will take atmospheric forcings from the start date specified in the\n    format YYYY-MM-DD\n    \"\"\"\n\n    data_path: Path\n    start_date: str  # YYYY-MM-DD\n    use_snow_data: bool = False\n    SW_forcing: DimensionalSWForcing = DimensionalConstantSWForcing()\n    LW_forcing: DimensionalLWForcing = DimensionalConstantLWForcing()\n    turbulent_flux: DimensionalTurbulentFlux = DimensionalConstantTurbulentFlux()\n    oil_heating: DimensionalOilHeating = DimensionalBackgroundOilHeating()\n</code></pre>"},{"location":"#seaice3p.params.dimensional.forcing.DimensionalRobinForcing","title":"<code>DimensionalRobinForcing</code>  <code>dataclass</code>","text":"<p>This forcing imposes a Robin boundary condition of the form surface_heat_flux=heat_transfer_coefficient * (restoring_temp - surface_temp)</p> Source code in <code>seaice3p/params/dimensional/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalRobinForcing:\n    \"\"\"This forcing imposes a Robin boundary condition of the form\n    surface_heat_flux=heat_transfer_coefficient * (restoring_temp - surface_temp)\n    \"\"\"\n\n    heat_transfer_coefficient: float = 6.3  # W/m2K\n    restoring_temperature: float = -30  # deg C\n</code></pre>"},{"location":"#seaice3p.params.dimensional.initial_conditions","title":"<code>initial_conditions</code>","text":""},{"location":"#seaice3p.params.dimensional.initial_conditions.BRW09InitialConditions","title":"<code>BRW09InitialConditions</code>  <code>dataclass</code>","text":"<p>values for bottom (ocean) boundary</p> Source code in <code>seaice3p/params/dimensional/initial_conditions.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass BRW09InitialConditions:\n    \"\"\"values for bottom (ocean) boundary\"\"\"\n\n    Barrow_initial_bulk_gas_in_ice: float = 1 / 5\n</code></pre>"},{"location":"#seaice3p.params.dimensional.initial_conditions.UniformInitialConditions","title":"<code>UniformInitialConditions</code>  <code>dataclass</code>","text":"<p>values for bottom (ocean) boundary</p> Source code in <code>seaice3p/params/dimensional/initial_conditions.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass UniformInitialConditions:\n    \"\"\"values for bottom (ocean) boundary\"\"\"\n</code></pre>"},{"location":"#seaice3p.params.dimensional.numerical","title":"<code>numerical</code>","text":""},{"location":"#seaice3p.params.dimensional.numerical.NumericalParams","title":"<code>NumericalParams</code>  <code>dataclass</code>","text":"<p>parameters needed for discretisation and choice of numerical method</p> Source code in <code>seaice3p/params/dimensional/numerical.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass NumericalParams:\n    \"\"\"parameters needed for discretisation and choice of numerical method\"\"\"\n\n    I: int = 50\n    regularisation: float = 1e-6\n    solver_choice: str = \"RK23\"  # scipy.integrate.solve_IVP solver choice\n\n    @property\n    def step(self):\n        return 1 / self.I\n</code></pre>"},{"location":"#seaice3p.params.dimensional.ocean_forcing","title":"<code>ocean_forcing</code>","text":""},{"location":"#seaice3p.params.dimensional.ocean_forcing.DimensionalBRW09OceanForcing","title":"<code>DimensionalBRW09OceanForcing</code>  <code>dataclass</code>","text":"<p>Ocean temperature provided by Barrow 2009 data at 2.4m and specify ocean fixed gas saturation state</p> Source code in <code>seaice3p/params/dimensional/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalBRW09OceanForcing:\n    \"\"\"Ocean temperature provided by Barrow 2009 data at 2.4m and specify ocean\n    fixed gas saturation state\"\"\"\n\n    pass\n</code></pre>"},{"location":"#seaice3p.params.dimensional.ocean_forcing.DimensionalFixedHeatFluxOceanForcing","title":"<code>DimensionalFixedHeatFluxOceanForcing</code>  <code>dataclass</code>","text":"<p>Provides constant ocean heat flux at the bottom of the domain</p> <p>Parameters:</p> Name Type Description Default <code>ocean_heat_flux</code> <code>float</code> <p>The constant heat flux at the bottom of the domain in W/m2</p> <code>1</code> Source code in <code>seaice3p/params/dimensional/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalFixedHeatFluxOceanForcing:\n    \"\"\"Provides constant ocean heat flux at the bottom of the domain\n\n    Args:\n        ocean_heat_flux: The constant heat flux at the bottom of the domain in W/m2\n    \"\"\"\n\n    ocean_heat_flux: float = 1\n</code></pre>"},{"location":"#seaice3p.params.dimensional.ocean_forcing.DimensionalFixedTempOceanForcing","title":"<code>DimensionalFixedTempOceanForcing</code>  <code>dataclass</code>","text":"<p>Fixed temperature and gas saturation ocean boundary condition</p> Source code in <code>seaice3p/params/dimensional/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalFixedTempOceanForcing:\n    \"\"\"Fixed temperature and gas saturation ocean boundary condition\"\"\"\n\n    ocean_temp: float = -1\n</code></pre>"},{"location":"#seaice3p.params.dimensional.water","title":"<code>water</code>","text":""},{"location":"#seaice3p.params.dimensional.water.CubicLiquidus","title":"<code>CubicLiquidus</code>  <code>dataclass</code>","text":"<p>Cubic fit to liquidus to give liquidus salinity in terms of temperature</p> <p>S = a0 + a1 T + a2 T^2 + a3 T^3</p> <p>defaults are taken from Notz PhD thesis for fit to Assur seawater data</p> Source code in <code>seaice3p/params/dimensional/water.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass CubicLiquidus:\n    \"\"\"Cubic fit to liquidus to give liquidus salinity in terms of temperature\n\n    S = a0 + a1 T + a2 T^2 + a3 T^3\n\n    defaults are taken from Notz PhD thesis for fit to Assur seawater data\n    \"\"\"\n\n    eutectic_temperature: float = -21.1  # deg Celsius\n    a0: float = -1.2\n    a1: float = -21.8\n    a2: float = -0.919\n    a3: float = -0.0178\n\n    def get_liquidus_salinity(self, temperature):\n        return (\n            self.a0\n            + self.a1 * temperature\n            + self.a2 * temperature**2\n            + self.a3 * temperature**3\n        )\n\n    def get_liquidus_temperature(self, salinity):\n        temperature = fsolve(\n            lambda x: salinity - self.get_liquidus_salinity(x),\n            np.full_like(salinity, -2),\n        )\n        if temperature.size == 1:\n            return temperature[0]\n        else:\n            return temperature\n</code></pre>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams","title":"<code>DimensionalWaterParams</code>  <code>dataclass</code>","text":"Source code in <code>seaice3p/params/dimensional/water.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DimensionalWaterParams:\n    liquid_density: float = 1028  # kg/m3\n    ice_density: float = 916  # kg/m3\n    ocean_salinity: float = 34  # g/kg\n    liquidus: LinearLiquidus | CubicLiquidus = LinearLiquidus()\n    latent_heat: float = 334e3  # latent heat of fusion for ice in J/kg\n    liquid_specific_heat_capacity: float = 4184  # J/kg degC\n    solid_specific_heat_capacity: float = 2009  # J/kg degC\n    liquid_thermal_conductivity: float = 0.54  # water thermal conductivity in W/m deg C\n    solid_thermal_conductivity: float = 2.22  # ice thermal conductivity in W/m deg C\n    snow_thermal_conductivity: float = 0.31  # snow thermal conductivity in W/m deg C\n    snow_density: float = 150  # snow density kg/m3\n\n    eddy_diffusivity: float = 0\n\n    salt_diffusivity: float = 0  # molecular diffusivity of salt in water in m2/s\n    # used to calculate Rayleigh number for convection and density contraction in liquid equation of state\n    haline_contraction_coefficient: float = 7.5e-4  # 1/ppt\n\n    # calculated from moreau et al 2014 value of kinematic viscosity for sewater 2.7e-6\n    # dynamic liquid_viscosity = 2.7e-6 * liquid_density\n    liquid_viscosity: float = 2.78e-3  # dynamic liquid viscosity in Pa.s\n\n    @property\n    def eutectic_salinity(self):\n        if isinstance(self.liquidus, LinearLiquidus):\n            return self.liquidus.eutectic_salinity\n        if isinstance(self.liquidus, CubicLiquidus):\n            return self.liquidus.get_liquidus_salinity(\n                self.liquidus.eutectic_temperature\n            )\n\n        raise NotImplementedError\n\n    @property\n    def eutectic_temperature(self):\n        if isinstance(self.liquidus, LinearLiquidus) or isinstance(\n            self.liquidus, CubicLiquidus\n        ):\n            return self.liquidus.eutectic_temperature\n\n        raise NotImplementedError\n\n    @property\n    def salinity_difference(self):\n        r\"\"\"calculate difference between eutectic salinity and typical ocean salinity\n\n        .. math:: \\Delta S = S_E - S_i\n\n        \"\"\"\n        return self.eutectic_salinity - self.ocean_salinity\n\n    @property\n    def ocean_freezing_temperature(self):\n        \"\"\"calculate salinity dependent freezing temperature using linear liquidus with\n        ocean salinity\n\n        .. math:: T_i = T_L(S_i) = T_E S_i / S_E\n\n        or using a cubic fit for the liquidus curve\n\n        \"\"\"\n        if isinstance(self.liquidus, LinearLiquidus):\n            return (\n                self.eutectic_temperature * self.ocean_salinity / self.eutectic_salinity\n            )\n        if isinstance(self.liquidus, CubicLiquidus):\n            return self.liquidus.get_liquidus_temperature(self.ocean_salinity)\n\n        raise NotImplementedError\n\n    @property\n    def temperature_difference(self):\n        r\"\"\"calculate\n\n        .. math:: \\Delta T = T_i - T_E\n\n        \"\"\"\n        return self.ocean_freezing_temperature - self.eutectic_temperature\n\n    @property\n    def concentration_ratio(self):\n        r\"\"\"Calculate concentration ratio as\n\n        .. math:: \\mathcal{C} = S_i / \\Delta S\n\n        \"\"\"\n        return self.ocean_salinity / self.salinity_difference\n\n    @property\n    def stefan_number(self):\n        r\"\"\"calculate Stefan number\n\n        .. math:: \\text{St} = L / c_p \\Delta T\n\n        \"\"\"\n        return self.latent_heat / (\n            self.temperature_difference * self.liquid_specific_heat_capacity\n        )\n\n    @property\n    def thermal_diffusivity(self):\n        r\"\"\"Return thermal diffusivity in m2/s\n\n        .. math:: \\kappa = \\frac{k}{\\rho_l c_p}\n\n        \"\"\"\n        return self.liquid_thermal_conductivity / (\n            self.liquid_density * self.liquid_specific_heat_capacity\n        )\n\n    @property\n    def conductivity_ratio(self):\n        r\"\"\"Calculate the ratio of solid to liquid thermal conductivity\n\n        .. math:: \\lambda = \\frac{k_s}{k_l}\n\n        \"\"\"\n        return self.solid_thermal_conductivity / self.liquid_thermal_conductivity\n\n    @property\n    def specific_heat_ratio(self):\n        r\"\"\"Calculate the ratio of solid to liquid specific heat capacities\n\n        .. math:: \\lambda = \\frac{c_{p,s}}{c_{p,l}}\n\n        \"\"\"\n        return self.solid_specific_heat_capacity / self.liquid_specific_heat_capacity\n\n    @property\n    def eddy_diffusivity_ratio(self):\n        r\"\"\"Calculate the ratio of eddy diffusivity to thermal diffusivity in\n        the liquid phase\n\n        .. math:: \\lambda = \\frac{\\kappa_\\text{turbulent}}{\\kappa_l}\n\n        \"\"\"\n        return self.eddy_diffusivity / self.thermal_diffusivity\n\n    @property\n    def snow_conductivity_ratio(self):\n        r\"\"\"Calculate the ratio of snow to liquid thermal conductivity\n\n        .. math:: \\lambda = \\frac{k_{sn}}{k_l}\n\n        \"\"\"\n        return self.snow_thermal_conductivity / self.liquid_thermal_conductivity\n\n    @property\n    def lewis_salt(self):\n        r\"\"\"Calculate the lewis number for salt, return np.inf if there is no salt\n        diffusion.\n\n        .. math:: \\text{Le}_S = \\kappa / D_s\n\n        \"\"\"\n        if self.salt_diffusivity == 0:\n            return np.inf\n\n        return self.thermal_diffusivity / self.salt_diffusivity\n</code></pre>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams.concentration_ratio","title":"<code>concentration_ratio</code>  <code>property</code>","text":"<p>Calculate concentration ratio as</p> <p>.. math:: \\mathcal{C} = S_i / \\Delta S</p>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams.conductivity_ratio","title":"<code>conductivity_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of solid to liquid thermal conductivity</p> <p>.. math:: \\lambda = \\frac{k_s}{k_l}</p>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams.eddy_diffusivity_ratio","title":"<code>eddy_diffusivity_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of eddy diffusivity to thermal diffusivity in the liquid phase</p> <p>.. math:: \\lambda = \\frac{\\kappa_\\text{turbulent}}{\\kappa_l}</p>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams.lewis_salt","title":"<code>lewis_salt</code>  <code>property</code>","text":"<p>Calculate the lewis number for salt, return np.inf if there is no salt diffusion.</p> <p>.. math:: \\text{Le}_S = \\kappa / D_s</p>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams.ocean_freezing_temperature","title":"<code>ocean_freezing_temperature</code>  <code>property</code>","text":"<p>calculate salinity dependent freezing temperature using linear liquidus with ocean salinity</p> <p>.. math:: T_i = T_L(S_i) = T_E S_i / S_E</p> <p>or using a cubic fit for the liquidus curve</p>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams.salinity_difference","title":"<code>salinity_difference</code>  <code>property</code>","text":"<p>calculate difference between eutectic salinity and typical ocean salinity</p> <p>.. math:: \\Delta S = S_E - S_i</p>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams.snow_conductivity_ratio","title":"<code>snow_conductivity_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of snow to liquid thermal conductivity</p> <p>.. math:: \\lambda = \\frac{k_{sn}}{k_l}</p>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams.specific_heat_ratio","title":"<code>specific_heat_ratio</code>  <code>property</code>","text":"<p>Calculate the ratio of solid to liquid specific heat capacities</p> <p>.. math:: \\lambda = \\frac{c_{p,s}}{c_{p,l}}</p>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams.stefan_number","title":"<code>stefan_number</code>  <code>property</code>","text":"<p>calculate Stefan number</p> <p>.. math:: \\text{St} = L / c_p \\Delta T</p>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams.temperature_difference","title":"<code>temperature_difference</code>  <code>property</code>","text":"<p>calculate</p> <p>.. math:: \\Delta T = T_i - T_E</p>"},{"location":"#seaice3p.params.dimensional.water.DimensionalWaterParams.thermal_diffusivity","title":"<code>thermal_diffusivity</code>  <code>property</code>","text":"<p>Return thermal diffusivity in m2/s</p> <p>.. math:: \\kappa = \\frac{k}{\\rho_l c_p}</p>"},{"location":"#seaice3p.params.forcing","title":"<code>forcing</code>","text":""},{"location":"#seaice3p.params.forcing.BRW09Forcing","title":"<code>BRW09Forcing</code>","text":"<p>Surface and ocean temperature data loaded from thermistor temperature record during the Barrow 2009 field study.</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\nclass BRW09Forcing:\n    \"\"\"Surface and ocean temperature data loaded from thermistor temperature record\n    during the Barrow 2009 field study.\n    \"\"\"\n\n    Barrow_top_temperature_data_choice: str = \"air\"\n\n    def __post_init__(self):\n        \"\"\"populate class attributes with barrow dimensional air temperature\n        and time in days (with missing values filtered out).\n\n        Note the metadata explaining how to use the barrow temperature data is also\n        in seaice3p/forcing_data. The indices corresponding to days and air temp are\n        hard coded in as class variables.\n        \"\"\"\n        DATA_INDICES = {\n            \"time\": 0,\n            \"air\": 8,\n            \"bottom_snow\": 18,\n            \"top_ice\": 19,\n        }\n        data = np.genfromtxt(\n            Path(__file__).parent.parent / \"forcing_data/BRW09.txt\", delimiter=\"\\t\"\n        )\n        top_temp_index = DATA_INDICES[self.Barrow_top_temperature_data_choice]\n        time_index = DATA_INDICES[\"time\"]\n\n        barrow_top_temp = data[:, top_temp_index]\n        barrow_days = data[:, time_index] - data[0, time_index]\n        barrow_top_temp, barrow_days = _filter_missing_values(\n            barrow_top_temp, barrow_days\n        )\n\n        self.barrow_top_temp = barrow_top_temp\n        self.barrow_days = barrow_days\n</code></pre>"},{"location":"#seaice3p.params.forcing.BRW09Forcing.__post_init__","title":"<code>__post_init__()</code>","text":"<p>populate class attributes with barrow dimensional air temperature and time in days (with missing values filtered out).</p> <p>Note the metadata explaining how to use the barrow temperature data is also in seaice3p/forcing_data. The indices corresponding to days and air temp are hard coded in as class variables.</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>def __post_init__(self):\n    \"\"\"populate class attributes with barrow dimensional air temperature\n    and time in days (with missing values filtered out).\n\n    Note the metadata explaining how to use the barrow temperature data is also\n    in seaice3p/forcing_data. The indices corresponding to days and air temp are\n    hard coded in as class variables.\n    \"\"\"\n    DATA_INDICES = {\n        \"time\": 0,\n        \"air\": 8,\n        \"bottom_snow\": 18,\n        \"top_ice\": 19,\n    }\n    data = np.genfromtxt(\n        Path(__file__).parent.parent / \"forcing_data/BRW09.txt\", delimiter=\"\\t\"\n    )\n    top_temp_index = DATA_INDICES[self.Barrow_top_temperature_data_choice]\n    time_index = DATA_INDICES[\"time\"]\n\n    barrow_top_temp = data[:, top_temp_index]\n    barrow_days = data[:, time_index] - data[0, time_index]\n    barrow_top_temp, barrow_days = _filter_missing_values(\n        barrow_top_temp, barrow_days\n    )\n\n    self.barrow_top_temp = barrow_top_temp\n    self.barrow_days = barrow_days\n</code></pre>"},{"location":"#seaice3p.params.forcing.ConstantForcing","title":"<code>ConstantForcing</code>  <code>dataclass</code>","text":"<p>Constant temperature forcing</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass ConstantForcing:\n    \"\"\"Constant temperature forcing\"\"\"\n\n    constant_top_temperature: float = -1.5\n</code></pre>"},{"location":"#seaice3p.params.forcing.ERA5Forcing","title":"<code>ERA5Forcing</code>","text":"<p>Forcing parameters for simulation forced with atmospheric variables from reanalysis data in netCDF file located at data_path.</p> <p>Never create this object directly but instead initialise from a dimensional simulation configuration as we must pass it the simulation timescale to correctly read the atmospheric variables from the netCDF file.</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\nclass ERA5Forcing:\n    \"\"\"Forcing parameters for simulation forced with atmospheric variables\n    from reanalysis data in netCDF file located at data_path.\n\n    Never create this object directly but instead initialise from a dimensional\n    simulation configuration as we must pass it the simulation timescale to correctly\n    read the atmospheric variables from the netCDF file.\n    \"\"\"\n\n    data_path: Path\n    start_date: str\n    timescale_in_days: float\n    use_snow_data: bool = False\n    snow_density: Optional[float] = None\n    SW_forcing: DimensionalSWForcing = DimensionalConstantSWForcing()\n    LW_forcing: DimensionalLWForcing = DimensionalConstantLWForcing()\n    turbulent_flux: DimensionalTurbulentFlux = DimensionalConstantTurbulentFlux()\n    oil_heating: DimensionalOilHeating = DimensionalBackgroundOilHeating()\n\n    def __post_init__(self):\n        data = xr.open_dataset(self.data_path)\n        daily_data = data.resample(valid_time=\"1d\").mean()\n        DATES = daily_data.valid_time.to_numpy()\n        DIMLESS_TIMES = (1 / self.timescale_in_days) * np.array(\n            [\n                (date - np.datetime64(self.start_date)) / np.timedelta64(1, \"D\")\n                for date in DATES\n            ]\n        )\n\n        # convert to deg C\n        T2M = daily_data.t2m[:, 0, 0].to_numpy() - 273.15\n        D2M = daily_data.d2m[:, 0, 0].to_numpy() - 273.15\n\n        LW = daily_data.msdwlwrf[:, 0, 0].to_numpy()\n        SW = daily_data.msdwswrf[:, 0, 0].to_numpy()\n\n        # convert to KPa\n        ATM = daily_data.sp[:, 0, 0].to_numpy() / 1e3\n\n        # Calculate specific humidity in kg/kg from dewpoint temperature\n        SPEC_HUM = _calculate_specific_humidity(ATM, D2M)\n\n        # Convert snow depth from m of water equivalent to m of snow\n        if self.use_snow_data:\n            if self.snow_density is None:\n                raise ValueError(\"No snow density provided\")\n            SNOW_DEPTH = daily_data.sd[:, 0, 0].to_numpy() * (1000 / self.snow_density)\n        else:\n            SNOW_DEPTH = np.zeros_like(DIMLESS_TIMES)\n\n        self.get_2m_temp = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=T2M, left=np.nan, right=np.nan\n        )\n        self.get_LW = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=LW, left=np.nan, right=np.nan\n        )\n        self.get_SW = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=SW, left=np.nan, right=np.nan\n        )\n        self.get_ATM = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=ATM, left=np.nan, right=np.nan\n        )\n        self.get_spec_hum = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=SPEC_HUM, left=np.nan, right=np.nan\n        )\n        self.get_snow_depth = partial(\n            np.interp, xp=DIMLESS_TIMES, fp=SNOW_DEPTH, left=np.nan, right=np.nan\n        )\n</code></pre>"},{"location":"#seaice3p.params.forcing.RadForcing","title":"<code>RadForcing</code>  <code>dataclass</code>","text":"<p>Forcing parameters for radiative transfer simulation with oil drops</p> <p>we have not implemented the non-dimensionalisation for these parameters yet and so we just pass the dimensional values directly to the simulation</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass RadForcing:\n    \"\"\"Forcing parameters for radiative transfer simulation with oil drops\n\n    we have not implemented the non-dimensionalisation for these parameters yet\n    and so we just pass the dimensional values directly to the simulation\"\"\"\n\n    SW_forcing: DimensionalSWForcing = DimensionalConstantSWForcing()\n    LW_forcing: DimensionalLWForcing = DimensionalConstantLWForcing()\n    turbulent_flux: DimensionalTurbulentFlux = DimensionalConstantTurbulentFlux()\n    oil_heating: DimensionalOilHeating = DimensionalBackgroundOilHeating()\n</code></pre>"},{"location":"#seaice3p.params.forcing.RobinForcing","title":"<code>RobinForcing</code>  <code>dataclass</code>","text":"<p>Dimensionless forcing parameters for Robin boundary condition</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass RobinForcing:\n    \"\"\"Dimensionless forcing parameters for Robin boundary condition\"\"\"\n\n    biot: float = 12\n    restoring_temperature: float = -1.3\n</code></pre>"},{"location":"#seaice3p.params.forcing.YearlyForcing","title":"<code>YearlyForcing</code>  <code>dataclass</code>","text":"<p>Yearly sinusoidal temperature forcing</p> Source code in <code>seaice3p/params/forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass YearlyForcing:\n    \"\"\"Yearly sinusoidal temperature forcing\"\"\"\n\n    offset: float = -1.0\n    amplitude: float = 0.75\n    period: float = 4.0\n</code></pre>"},{"location":"#seaice3p.params.initial_conditions","title":"<code>initial_conditions</code>","text":""},{"location":"#seaice3p.params.initial_conditions.OilInitialConditions","title":"<code>OilInitialConditions</code>  <code>dataclass</code>","text":"<p>values for bottom (ocean) boundary</p> Source code in <code>seaice3p/params/initial_conditions.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass OilInitialConditions:\n    \"\"\"values for bottom (ocean) boundary\"\"\"\n\n    # Non dimensional parameters for summer initial conditions\n    initial_ice_depth: float = 0.5\n    initial_ocean_temperature: float = -0.05\n    initial_ice_temperature: float = -0.1\n    initial_oil_volume_fraction: float = 1e-7\n    initial_ice_bulk_salinity: float = -0.1\n    initial_oil_free_depth: float = 0\n</code></pre>"},{"location":"#seaice3p.params.ocean_forcing","title":"<code>ocean_forcing</code>","text":""},{"location":"#seaice3p.params.ocean_forcing.BRW09OceanForcing","title":"<code>BRW09OceanForcing</code>","text":"<p>Ocean temperature provided by Barrow 2009 data at 2.4m and specify ocean fixed gas saturation state</p> Source code in <code>seaice3p/params/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\nclass BRW09OceanForcing:\n    \"\"\"Ocean temperature provided by Barrow 2009 data at 2.4m and specify ocean\n    fixed gas saturation state\"\"\"\n\n    ocean_gas_sat: float = 1.0\n\n    def __post_init__(self):\n        \"\"\"populate class attributes with barrow dimensional ocean temperature\n        and time in days (with missing values filtered out).\n\n        Note the metadata explaining how to use the barrow temperature data is also\n        in seaice3p/forcing_data.\n        \"\"\"\n        data = np.genfromtxt(\n            Path(__file__).parent.parent / \"forcing_data/BRW09.txt\", delimiter=\"\\t\"\n        )\n        ocean_temp_index = 43\n        time_index = 0\n\n        barrow_bottom_temp = data[:, ocean_temp_index]\n        barrow_ocean_days = data[:, time_index] - data[0, time_index]\n        barrow_bottom_temp, barrow_ocean_days = _filter_missing_values(\n            barrow_bottom_temp, barrow_ocean_days\n        )\n\n        self.barrow_bottom_temp = barrow_bottom_temp\n        self.barrow_ocean_days = barrow_ocean_days\n</code></pre>"},{"location":"#seaice3p.params.ocean_forcing.BRW09OceanForcing.__post_init__","title":"<code>__post_init__()</code>","text":"<p>populate class attributes with barrow dimensional ocean temperature and time in days (with missing values filtered out).</p> <p>Note the metadata explaining how to use the barrow temperature data is also in seaice3p/forcing_data.</p> Source code in <code>seaice3p/params/ocean_forcing.py</code> <pre><code>def __post_init__(self):\n    \"\"\"populate class attributes with barrow dimensional ocean temperature\n    and time in days (with missing values filtered out).\n\n    Note the metadata explaining how to use the barrow temperature data is also\n    in seaice3p/forcing_data.\n    \"\"\"\n    data = np.genfromtxt(\n        Path(__file__).parent.parent / \"forcing_data/BRW09.txt\", delimiter=\"\\t\"\n    )\n    ocean_temp_index = 43\n    time_index = 0\n\n    barrow_bottom_temp = data[:, ocean_temp_index]\n    barrow_ocean_days = data[:, time_index] - data[0, time_index]\n    barrow_bottom_temp, barrow_ocean_days = _filter_missing_values(\n        barrow_bottom_temp, barrow_ocean_days\n    )\n\n    self.barrow_bottom_temp = barrow_bottom_temp\n    self.barrow_ocean_days = barrow_ocean_days\n</code></pre>"},{"location":"#seaice3p.params.ocean_forcing.FixedHeatFluxOceanForcing","title":"<code>FixedHeatFluxOceanForcing</code>  <code>dataclass</code>","text":"<p>Provides constant dimensionless ocean heat flux at the bottom of the domain and fixed gas saturation state.</p> Source code in <code>seaice3p/params/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass FixedHeatFluxOceanForcing:\n    \"\"\"Provides constant dimensionless ocean heat flux at the bottom of the domain and fixed gas\n    saturation state.\"\"\"\n\n    ocean_heat_flux: float = 1\n    ocean_gas_sat: float = 1.0\n</code></pre>"},{"location":"#seaice3p.params.ocean_forcing.FixedTempOceanForcing","title":"<code>FixedTempOceanForcing</code>  <code>dataclass</code>","text":"<p>Fixed temperature and gas saturation ocean boundary condition</p> Source code in <code>seaice3p/params/ocean_forcing.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass FixedTempOceanForcing:\n    \"\"\"Fixed temperature and gas saturation ocean boundary condition\"\"\"\n\n    ocean_temp: float = 0.1\n    ocean_gas_sat: float = 1.0\n</code></pre>"},{"location":"#seaice3p.params.params","title":"<code>params</code>","text":"<p>Classes containing parameters required to run a simulation</p> <p>The config class contains all the parameters needed to run a simulation as well as methods to save and load this configuration to a yaml file.</p>"},{"location":"#seaice3p.params.params.Config","title":"<code>Config</code>  <code>dataclass</code>","text":"<p>contains all information needed to run a simulation and save output</p> <p>this config object can be saved and loaded to a yaml file.</p> Source code in <code>seaice3p/params/params.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass Config:\n    \"\"\"contains all information needed to run a simulation and save output\n\n    this config object can be saved and loaded to a yaml file.\"\"\"\n\n    name: str\n    total_time: float\n    savefreq: float\n\n    physical_params: PhysicalParams\n    bubble_params: BubbleParams\n    brine_convection_params: BrineConvectionParams\n    forcing_config: ForcingConfig\n    ocean_forcing_config: OceanForcingConfig\n    initial_conditions_config: InitialConditionsConfig\n    numerical_params: NumericalParams = NumericalParams()\n    scales: Scales | None = None\n\n    def save(self, directory: Path):\n        with open(directory / f\"{self.name}.yml\", \"w\") as outfile:\n            outfile.write(to_yaml(self))\n\n    @classmethod\n    def load(cls, path):\n        with open(path, \"r\") as infile:\n            yaml = infile.read()\n        return from_yaml(cls, yaml)\n</code></pre>"},{"location":"#seaice3p.params.params.get_config","title":"<code>get_config(dimensional_params)</code>","text":"<p>Return a Config object for the simulation.</p> <p>physical parameters and Darcy law parameters are calculated from the dimensional input. You can modify the numerical parameters and boundary conditions and forcing provided for the simulation.</p> Source code in <code>seaice3p/params/params.py</code> <pre><code>def get_config(dimensional_params: DimensionalParams) -&gt; Config:\n    \"\"\"Return a Config object for the simulation.\n\n    physical parameters and Darcy law parameters are calculated from the dimensional\n    input. You can modify the numerical parameters and boundary conditions and\n    forcing provided for the simulation.\"\"\"\n    physical_params = get_dimensionless_physical_params(dimensional_params)\n    initial_conditions_config = get_dimensionless_initial_conditions_config(\n        dimensional_params\n    )\n    brine_convection_params = get_dimensionless_brine_convection_params(\n        dimensional_params\n    )\n    bubble_params = get_dimensionless_bubble_params(dimensional_params)\n    forcing_config = get_dimensionless_forcing_config(dimensional_params)\n    ocean_forcing_config = get_dimensionless_ocean_forcing_config(dimensional_params)\n    return Config(\n        name=dimensional_params.name,\n        physical_params=physical_params,\n        initial_conditions_config=initial_conditions_config,\n        brine_convection_params=brine_convection_params,\n        bubble_params=bubble_params,\n        forcing_config=forcing_config,\n        ocean_forcing_config=ocean_forcing_config,\n        numerical_params=dimensional_params.numerical_params,\n        scales=dimensional_params.scales,\n        total_time=dimensional_params.total_time,\n        savefreq=dimensional_params.savefreq,\n    )\n</code></pre>"},{"location":"#seaice3p.params.physical","title":"<code>physical</code>","text":""},{"location":"#seaice3p.params.physical.BasePhysicalParams","title":"<code>BasePhysicalParams</code>  <code>dataclass</code>","text":"<p>Not to be used directly but provides the common parameters for physical params objects</p> Source code in <code>seaice3p/params/physical.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass BasePhysicalParams:\n    \"\"\"Not to be used directly but provides the common parameters for physical params\n    objects\n    \"\"\"\n\n    expansion_coefficient: float = 0.029\n    concentration_ratio: float = 0.17\n    stefan_number: float = 4.2\n    lewis_salt: float = np.inf\n    lewis_gas: float = np.inf\n    frame_velocity: float = 0\n\n    specific_heat_ratio: float = 0.5\n    conductivity_ratio: float = 4.11\n    eddy_diffusivity_ratio: float = 0\n    snow_conductivity_ratio: float = 0.574\n\n    # Option to change tolerable supersaturation\n    tolerable_super_saturation_fraction: float = 1\n\n    gas_viscosity_ratio: float = 0\n    gas_bubble_eddy_diffusion: bool = False\n\n    get_liquidus_temperature: Optional[Callable] = None\n    get_liquidus_salinity: Optional[Callable] = None\n</code></pre>"},{"location":"#seaice3p.params.physical.DISEQPhysicalParams","title":"<code>DISEQPhysicalParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BasePhysicalParams</code></p> <p>non dimensional numbers for the mushy layer</p> Source code in <code>seaice3p/params/physical.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass DISEQPhysicalParams(BasePhysicalParams):\n    \"\"\"non dimensional numbers for the mushy layer\"\"\"\n\n    # only used in DISEQ model\n    damkohler_number: float = 1\n</code></pre>"},{"location":"#seaice3p.params.physical.EQMPhysicalParams","title":"<code>EQMPhysicalParams</code>  <code>dataclass</code>","text":"<p>               Bases: <code>BasePhysicalParams</code></p> <p>non dimensional numbers for the mushy layer</p> Source code in <code>seaice3p/params/physical.py</code> <pre><code>@serde(type_check=coerce)\n@dataclass(frozen=True)\nclass EQMPhysicalParams(BasePhysicalParams):\n    \"\"\"non dimensional numbers for the mushy layer\"\"\"\n</code></pre>"},{"location":"#seaice3p.plot","title":"<code>plot</code>","text":"<p>script to visualise simulation data</p> <p>usage: python -m seaice3p.plot \"glob pattern to find npz files\" Optional[True/False]</p> <p>assumes the simulation configurations are to be found in the same directory as the data. If the simulation is a non-dimensional configuration file add the False option after the glob pattern.</p>"},{"location":"#seaice3p.run_simulation","title":"<code>run_simulation</code>","text":"<p>Module to run the simulation on the given configuration with the appropriate solver.</p> <p>Solve reduced model using scipy solve_ivp using RK23 solver.</p> <p>Impose a maximum timestep constraint using courant number for thermal diffusion as this is an explicit method.</p> <p>This solver uses adaptive timestepping which makes it a good choice for running simulations with large buoyancy driven gas bubble velocities and we save the output at intervals given by the savefreq parameter in configuration.</p>"},{"location":"#seaice3p.run_simulation.run_batch","title":"<code>run_batch(list_of_cfg, directory, verbosity_level=0)</code>","text":"<p>Run a batch of simulations from a list of configurations.</p> <p>Each simulation name is logged, as well as if it successfully runs or crashes. Output from each simulation is saved in a .npz file.</p> <p>:param list_of_cfg: list of configurations :type list_of_cfg: List[seaice3p.params.Config]</p> Source code in <code>seaice3p/run_simulation.py</code> <pre><code>def run_batch(list_of_cfg: List[Config], directory: Path, verbosity_level=0) -&gt; None:\n    \"\"\"Run a batch of simulations from a list of configurations.\n\n    Each simulation name is logged, as well as if it successfully runs or crashes.\n    Output from each simulation is saved in a .npz file.\n\n    :param list_of_cfg: list of configurations\n    :type list_of_cfg: List[seaice3p.params.Config]\n\n    \"\"\"\n    optprint = get_printer(verbosity_level, verbosity_threshold=1)\n    for cfg in list_of_cfg:\n        optprint(f\"seaice3pv{__version__}: {cfg.name}\")\n        try:\n            solve(cfg, directory, verbosity_level=verbosity_level)\n        except Exception as e:\n            optprint(f\"{cfg.name} crashed\")\n            optprint(f\"{e}\")\n</code></pre>"},{"location":"#seaice3p.state","title":"<code>state</code>","text":""},{"location":"#seaice3p.state.disequilibrium_state","title":"<code>disequilibrium_state</code>","text":""},{"location":"#seaice3p.state.disequilibrium_state.DISEQState","title":"<code>DISEQState</code>  <code>dataclass</code>","text":"<p>Contains the principal variables for solution with non-equilibrium gas phase. The total bulk gas is partitioned between dissolved gas and free phase gas with a finite nucleation rate (non dimensional damkohler number).</p> <p>principal solution components: bulk enthalpy bulk salinity bulk dissolved gas gas fraction</p> <p>all on the center grid.</p> <p>Note: Define bulk dissolved gas for the system as</p> <p>expansion_coefficient * liquid_fraction * dissolved_gas</p> <p>so that this is different from the dissolved gas concentration and</p> <p>bulk_gas = bulk_dissolved_gas + gas_fraction</p> <p>in non-dimensional units.</p> Source code in <code>seaice3p/state/disequilibrium_state.py</code> <pre><code>@dataclass(frozen=True)\nclass DISEQState:\n    \"\"\"Contains the principal variables for solution with non-equilibrium gas phase.\n    The total bulk gas is partitioned between dissolved gas and free phase gas with\n    a finite nucleation rate (non dimensional damkohler number).\n\n    principal solution components:\n    bulk enthalpy\n    bulk salinity\n    bulk dissolved gas\n    gas fraction\n\n    all on the center grid.\n\n    Note:\n    Define bulk dissolved gas for the system as\n\n    expansion_coefficient * liquid_fraction * dissolved_gas\n\n    so that this is different from the dissolved gas concentration and\n\n    bulk_gas = bulk_dissolved_gas + gas_fraction\n\n    in non-dimensional units.\n    \"\"\"\n\n    time: float\n    enthalpy: NDArray\n    salt: NDArray\n    bulk_dissolved_gas: NDArray\n    gas_fraction: NDArray\n\n    @cached_property\n    def gas(self) -&gt; NDArray:\n        \"\"\"Calculate bulk gas content and use same attribute name as EQMState\"\"\"\n        return self.bulk_dissolved_gas + self.gas_fraction\n</code></pre>"},{"location":"#seaice3p.state.disequilibrium_state.DISEQState.gas","title":"<code>gas</code>  <code>cached</code> <code>property</code>","text":"<p>Calculate bulk gas content and use same attribute name as EQMState</p>"},{"location":"#seaice3p.state.disequilibrium_state.DISEQStateBCs","title":"<code>DISEQStateBCs</code>  <code>dataclass</code>","text":"<p>Stores information needed for solution at one timestep with BCs on ghost cells as well</p> <p>Initialiase the prime variables for the solver: enthalpy, bulk salinity and bulk air</p> Source code in <code>seaice3p/state/disequilibrium_state.py</code> <pre><code>@dataclass(frozen=True)\nclass DISEQStateBCs:\n    \"\"\"Stores information needed for solution at one timestep with BCs on ghost\n    cells as well\n\n    Initialiase the prime variables for the solver:\n    enthalpy, bulk salinity and bulk air\n    \"\"\"\n\n    time: float\n    enthalpy: NDArray\n    salt: NDArray\n\n    temperature: NDArray\n    liquid_salinity: NDArray\n    dissolved_gas: NDArray\n    liquid_fraction: NDArray\n    bulk_dissolved_gas: NDArray\n    gas_fraction: NDArray\n</code></pre>"},{"location":"#seaice3p.state.disequilibrium_state.DISEQStateFull","title":"<code>DISEQStateFull</code>  <code>dataclass</code>","text":"<p>Contains all variables variables for solution with non-equilibrium gas phase after running the enthalpy method on DISEQSate. The total bulk gas is partitioned between dissolved gas and free phase gas with a finite nucleation rate (non dimensional damkohler number).</p> <p>principal solution components: bulk enthalpy bulk salinity bulk dissolved gas gas fraction</p> <p>enthalpy method variables: temperature liquid_fraction solid_fraction liquid_salinity dissolved_gas</p> <p>all on the center grid.</p> <p>Note: Define bulk dissolved gas for the system as</p> <p>expansion_coefficient * liquid_fraction * dissolved_gas</p> <p>so that this is different from the dissolved gas concentration and</p> <p>bulk_gas = bulk_dissolved_gas + gas_fraction</p> <p>in non-dimensional units.</p> Source code in <code>seaice3p/state/disequilibrium_state.py</code> <pre><code>@dataclass(frozen=True)\nclass DISEQStateFull:\n    \"\"\"Contains all variables variables for solution with non-equilibrium gas phase\n    after running the enthalpy method on DISEQSate.\n    The total bulk gas is partitioned between dissolved gas and free phase gas with\n    a finite nucleation rate (non dimensional damkohler number).\n\n    principal solution components:\n    bulk enthalpy\n    bulk salinity\n    bulk dissolved gas\n    gas fraction\n\n    enthalpy method variables:\n    temperature\n    liquid_fraction\n    solid_fraction\n    liquid_salinity\n    dissolved_gas\n\n    all on the center grid.\n\n    Note:\n    Define bulk dissolved gas for the system as\n\n    expansion_coefficient * liquid_fraction * dissolved_gas\n\n    so that this is different from the dissolved gas concentration and\n\n    bulk_gas = bulk_dissolved_gas + gas_fraction\n\n    in non-dimensional units.\n    \"\"\"\n\n    time: float\n    enthalpy: NDArray\n    salt: NDArray\n    bulk_dissolved_gas: NDArray\n    gas_fraction: NDArray\n\n    temperature: NDArray\n    liquid_fraction: NDArray\n    solid_fraction: NDArray\n    liquid_salinity: NDArray\n    dissolved_gas: NDArray\n\n    @cached_property\n    def gas(self) -&gt; NDArray:\n        \"\"\"Calculate bulk gas content and use same attribute name as EQMState\"\"\"\n        return self.bulk_dissolved_gas + self.gas_fraction\n</code></pre>"},{"location":"#seaice3p.state.disequilibrium_state.DISEQStateFull.gas","title":"<code>gas</code>  <code>cached</code> <code>property</code>","text":"<p>Calculate bulk gas content and use same attribute name as EQMState</p>"},{"location":"#seaice3p.state.equilibrium_state","title":"<code>equilibrium_state</code>","text":""},{"location":"#seaice3p.state.equilibrium_state.EQMState","title":"<code>EQMState</code>  <code>dataclass</code>","text":"<p>Contains the principal variables for solution with equilibrium gas phase:</p> <p>bulk enthalpy bulk salinity bulk gas</p> <p>all on the center grid.</p> Source code in <code>seaice3p/state/equilibrium_state.py</code> <pre><code>@dataclass(frozen=True)\nclass EQMState:\n    \"\"\"Contains the principal variables for solution with equilibrium gas phase:\n\n    bulk enthalpy\n    bulk salinity\n    bulk gas\n\n    all on the center grid.\n    \"\"\"\n\n    time: float\n    enthalpy: NDArray\n    salt: NDArray\n    gas: NDArray\n</code></pre>"},{"location":"#seaice3p.state.equilibrium_state.EQMStateBCs","title":"<code>EQMStateBCs</code>  <code>dataclass</code>","text":"<p>Stores information needed for solution at one timestep with BCs on ghost cells as well</p> <p>Initialiase the prime variables for the solver: enthalpy, bulk salinity and bulk air</p> Source code in <code>seaice3p/state/equilibrium_state.py</code> <pre><code>@dataclass(frozen=True)\nclass EQMStateBCs:\n    \"\"\"Stores information needed for solution at one timestep with BCs on ghost\n    cells as well\n\n    Initialiase the prime variables for the solver:\n    enthalpy, bulk salinity and bulk air\n    \"\"\"\n\n    time: float\n    enthalpy: NDArray\n    salt: NDArray\n    gas: NDArray\n\n    temperature: NDArray\n    liquid_salinity: NDArray\n    dissolved_gas: NDArray\n    gas_fraction: NDArray\n    liquid_fraction: NDArray\n</code></pre>"},{"location":"#seaice3p.state.equilibrium_state.EQMStateFull","title":"<code>EQMStateFull</code>  <code>dataclass</code>","text":"<p>Contains all variables variables for solution with equilibrium gas phase after running the enthalpy method on EQMSate.</p> <p>principal solution components: bulk enthalpy bulk salinity bulk gas</p> <p>enthalpy method variables: temperature liquid_fraction solid_fraction liquid_salinity dissolved_gas gas_fraction</p> <p>all on the center grid.</p> Source code in <code>seaice3p/state/equilibrium_state.py</code> <pre><code>@dataclass(frozen=True)\nclass EQMStateFull:\n    \"\"\"Contains all variables variables for solution with equilibrium gas phase\n    after running the enthalpy method on EQMSate.\n\n    principal solution components:\n    bulk enthalpy\n    bulk salinity\n    bulk gas\n\n    enthalpy method variables:\n    temperature\n    liquid_fraction\n    solid_fraction\n    liquid_salinity\n    dissolved_gas\n    gas_fraction\n\n    all on the center grid.\n    \"\"\"\n\n    time: float\n    enthalpy: NDArray\n    salt: NDArray\n    gas: NDArray\n\n    temperature: NDArray\n    liquid_fraction: NDArray\n    solid_fraction: NDArray\n    liquid_salinity: NDArray\n    dissolved_gas: NDArray\n    gas_fraction: NDArray\n</code></pre>"},{"location":"Changelog/","title":"Changelog","text":""},{"location":"Changelog/#v0270-2025-01-15","title":"v0.27.0 (2025-01-15)","text":""},{"location":"Changelog/#summary","title":"Summary","text":"<p>Upgrade dependency for shortwave radiative transfer scheme oilrad 1.0.0 -&gt; 2.0.0. Use the SixBandModel for shortwave radiative transfer which better resolves the propagation of visible wavelengths through snow and SSL. Remove redundant parameters from shortwave forcing configuration and add paramters to specify snow and SSL spectral albedos and extinction coefficients and SSL thickness. Remove the redundant module oil_simulation.</p>"},{"location":"Changelog/#v0260-2024-11-04","title":"v0.26.0 (2024-11-04)","text":""},{"location":"Changelog/#summary_1","title":"Summary","text":"<p>Change to use mkdocs instead of sphinx to generate documentation. Upgrade oilrad 0.9.0 -&gt; 1.0.0 and upgrade to latest numpy and scipy versions. Add option to turn on or off advective heat flux in the ocean when using the RJW14 brine convection scheme. Do not run two-stream shortwave radiation model when shortwave flux reaching the top of the domain is less than 0.5 W/m2 (significant performance benefit). Export the results classes for better code completion when using seaice3p. Add extra verbosity options to the command line interface: '', '-v', or '-vv'. Add method to the scales object to calculate the dimensional heat flux in W/m2.</p>"},{"location":"Changelog/#v0250-2024-10-29","title":"v0.25.0 (2024-10-29)","text":""},{"location":"Changelog/#summary_2","title":"Summary","text":"<p>Fix bug in calculation of Courant number for methods using explicit timestepping. Linearly interpolate forcing quantities from ERA5 data instead of using cubic splines to avoid oscillations. Remove the arbitrary threshold in snow depth for surface boundary condition and shortwave radiative transfer. Instead use real snow depth in surface energy boundary condition and apply an exponential attenuation of shortwave radiation through the snow layer. This is assuming a perfectly scattering snow layer with the extra parameter snow_scattering_coefficient given in SW_forcing parameters.</p> <p>Update to use oilrad 0.9.0 for the two stream radiative transfer model. This requires specifying the appropriate ice_scattering_coefficient directly. Additionally, there is the optional absorption_enhancement_factor which accounts for extra absorption due to increase in vertical mean path length of a diffuse radiation field. The default values of these two new pararmeters best match the computed spectral albedo for 0ng/g of oil in 0.8m thick first-year sea ice in Redmond Roche et al 2022.</p>"},{"location":"Changelog/#v0240-2024-10-25","title":"v0.24.0 (2024-10-25)","text":""},{"location":"Changelog/#summary_3","title":"Summary","text":"<p>Add snow density as a parameter to the dimensional simulation (in water params). This will be used when using ERA5 snow depth data for forcing to infer the snow depth from the given measurement of m of water equivalent. This is important to be able to change as snow depth strongly impacts ice thickness.</p>"},{"location":"Changelog/#v0230-2024-10-18","title":"v0.23.0 (2024-10-18)","text":""},{"location":"Changelog/#summary_4","title":"Summary","text":"<p>As another measure to try and achieve realistic ice growth add the option to use a cubic fit for the liquidus curve. Data for this is taken from Dirk Notz PhD thesis. This should now predict a more accurate warmer temperature for the ocean water freezing temperature and so should promote more ice growth.</p>"},{"location":"Changelog/#v0220-2024-10-17","title":"v0.22.0 (2024-10-17)","text":""},{"location":"Changelog/#summary_5","title":"Summary","text":"<p>To avoid delivering spurious advective heat flux in the ocean when using the RJW14 brine convection scheme we now use an exponential to smoothly set the advective heat flux in the ocean to zero. This should improve the underestimate of ice growth compared to field observations.</p>"},{"location":"Changelog/#v0210-2024-10-11","title":"v0.21.0 (2024-10-11)","text":""},{"location":"Changelog/#summary_6","title":"Summary","text":"<p>Update dependencies so pip installs xarray, metpy and netcdf4 needed for running simulations with forcing from ERA5 data.</p> <p>To avoid numerical instability change the calculation of eddy diffusivity to turn on gradually as liquid fraction goes to 1 using an exponential. Set the scale for the exponential once as 5e-3 which should mean the diffusivity remains unmodified for liquid fraction less than 0.9. This seems to suppress instability and simulations can be run with the BDF solver for a year of ERA5 reanalysis forcing.</p> <p>Change the calculation of the enthalpy method to account for different specific heat capacities of the solid and liquid phases. This is important to predict the correct ice depth.</p>"},{"location":"Changelog/#v0200-2024-10-07","title":"v0.20.0 (2024-10-07)","text":""},{"location":"Changelog/#summary_7","title":"Summary","text":"<p>Add ERA5Forcing option for simulation configuration. This reads data from a single ERA5 reanalysis netcdf data file at the location provided in configuration. This file should onlu contain timeseries data for a single location (lat, lon location) and needs to contain the hourly variables: 2m air temperature, 2m dewpoint temperature, downward longwave radiation. downward shortwave radiation, and surface pressure. Optionally can also request to use dnow depth data from the data file. In this case the surface energy balance boundary condition is modified assuming a quasi steady homogeneous conductive snow layer. To read the netcdf file xarray and netCDF4 are added as dependencies as well as metpy to calculate specific humidity at 2m.</p> <p>Seperate the ocean boundary conditions into a sperate ocean_forcing_config. We have implemented three options: FixedTempOceanForcing, which provides fixed ocean temperature boudnary conditions; FixedHeatFluxOceanForcing, which provides a constant ocean heat flux; and BRW09OceanForcing, which provides the bottom ocean temperature from the data measured at 2.4m during the 2009 Barrow field study.</p> <p>Change from specifying the turbulent liquid thermal conductivity to simply specifying the eddy diffusivity. In purely liquid regions this enhances the diffusion of heat, salt and dissolved gas. Additionally added the option gas_bubble_eddy_diffusivity, when set to true this also adds eddy diffusion of the gas bubble phase. This is useful when simulating oil droplets instead of gas bubbles which are much less buoyant and should be mixed due to turbulence in the liquid.</p> <p>Added the gas_viscosity parameter. By default this is zero and we regain the terminal rise velocity calculation for a free slip sphere. However, when a non-zero value is supplied the Hadamaard-Rybczinski equation is used.</p> <p>Fixed a bug when implementing the brine convection sink so that now we may couple brine convection to the gas / oil droplet phase by setting the options couple_bubble_to_horizontal_flow and couple_bubble_to_vertical_flow to true. This is useful for simulating oil droplets or bubbles which have become trapped and are not migrating under their buoyancy.</p> <p>Added the dates property to the results class which can be calcuated for simulations forced useing ERA5Forcing as we specify a start date for these. Gives a list of datetimes of the data points of the simulation. Added methods to calculate meltpond onset time and surface heat fluxes of a simulation to the results class.</p>"},{"location":"Changelog/#v0190-2024-09-30","title":"v0.19.0 (2024-09-30)","text":""},{"location":"Changelog/#summary_8","title":"Summary","text":"<p>Change to use oilrad v0.7.0 for radiative transfer calculation. This allows us to use an optimized faster radiation solve if we set fast_solve=True. Given a cutoff wavelength you should choose based on the grid resolution for wavelengths above this approximate the radiation as entirely absorbed in the first grid cell.</p> <p>Add turbulent liquid thermal conductivity parameter to represent enhanced heat transport in liquid regions (ocean and meltpond). Also add the option to choose the solver used by scipy.integrate.solve_IVP. An implicit method such as the Radau or LSODA option is best used when an enhanced turbulent conductivity is added to avoid very small timesteps.</p> <p>Add option to load simulation initial condition as the final state of an existing saved simulation.</p> <p>Make gas fraction boundary condition extend the bottom value of the domain into the ocean. This is useful for simulating an oil configuration where oil will be able to rise into the domain.</p> <p>Add plot module to visualise saved simulation data from the command line.</p> <p>Add the initial_oil_free_ice_depth parameter to the oil simulation initial conditions config to specify the initial oil mass ratio profile as a step function with no oil in the upper portion of the domain. This is to simulate the release of oil below the ice at some time before the simulation starts.</p>"},{"location":"Changelog/#v0180-2024-09-26","title":"v0.18.0 (2024-09-26)","text":""},{"location":"Changelog/#summary_9","title":"Summary","text":"<p>Change to use oilrad v0.6.0 for radiative transfer calculation. Fix bug where non-dimensional grid was passed to oilrad causing incorrect internal melting. Fix implementation of surface energy balance to estimate surface temprature correctly. Create the load_simulation function to return a results class useful for plotting simulations. Add a forcing option for a Robin boundary condition. Fix bug in non-dimensionalisation of DISEQ model so that this can now be run.</p>"},{"location":"Changelog/#v0170-2024-09-21","title":"v0.17.0 (2024-09-21)","text":""},{"location":"Changelog/#summary_10","title":"Summary","text":"<p>Change to use oilrad v0.5.0 for radiative transfer calculation. This just takes liquid fraction within the entire domain and so solves a depth dependent radiative transfer model with meltpond and ocean regions present. Once a meltpond forms on the surface of the ice the surface SW penetration fraction is set to 1 as there can be no SSL when a meltpond has formed.</p>"},{"location":"Changelog/#v0160-2024-09-19","title":"v0.16.0 (2024-09-19)","text":""},{"location":"Changelog/#summary_11","title":"Summary","text":"<p>Change to use oilrad v0.4.0 for radiative transfer calculation. This now integrates accross all shortwave wavelengths so we no longer need to have the shortwave in the surface boundary condition. The SW_penetration_fraction dictates how much radiation passes through the initial surface scattering layer to the solver.</p>"},{"location":"Changelog/#v0150-2024-09-18","title":"v0.15.0 (2024-09-18)","text":""},{"location":"Changelog/#summary_12","title":"Summary","text":"<p>Renamed the project from the working name celestine to seaice3p. Updated to use python 3.12. Added verbosity option to command line interface -v. Removed logging to files. Major refactoring.</p> <p>Removed redundant enthalpy method and solver classes. Simulation state is stored in the State object which keeps the prime variables. Running the enthalpy method on this onbect produces a StateFull object with the enthalpy method variables. Applying the boundary conditions to this object produces the StateBCs object used in the solver. Broken up to configuration of the simulation to be handled by different objects. This should mean only necessary parameters for the type of simulation being run need to be given. Use pyserde to serialize these configuration objects. Added a load module to read in data from simulations.</p> <p>Implemented a disequilibrium model for gas dynamics with a finite nucleation rate.</p> <p>Added convenience function to adapt gas dynamics to simulate oil droplets. The buoyancy parameter is now calculated as the difference in fluid and oil/gas density. When simulating oil droplets the top velocity is changed to prevent oil escaping the top surface.</p> <p>Implemented a radiative forcing configuration which uses a surface energy balance to calculate the appropriate temperature boundary condition. Also use the radiative transfer model <code>oilrad</code> (v0.3.0) to calculate internal radiative heating due to  shortwave absorption of ice and oil droplets. Created an initial condition to investigate melting a layer of ice under radiative and turbulent surface fluxes.</p>"},{"location":"Changelog/#v0140-2024-04-23","title":"v0.14.0 (2024-04-23)","text":""},{"location":"Changelog/#summary_13","title":"Summary","text":"<p>No new physics in this version just changed the structure so that tests are run with pytest. Example script is now a module <code>celestine.example</code>. Scripts that plotted gas velocity and brine drainage parameterisation quantities were useful so have been moved to a diagnostics module.</p>"},{"location":"Changelog/#tests","title":"Tests","text":"<ul> <li>Run all tests with pytest.</li> <li>Run tests that aren't slow with <code>pytest -m \"not slow\"</code>.</li> </ul>"},{"location":"Changelog/#docs","title":"Docs","text":"<ul> <li>Update installation instructions in the README.</li> </ul>"},{"location":"Changelog/#v0130-2024-04-22","title":"v0.13.0 (2024-04-22)","text":""},{"location":"Changelog/#summary_14","title":"Summary","text":"<p>To investigate the effect of gas nucleation rate without changing the equilibrium model significantly add parameters that control tolerable supersaturation and ocean saturation state. This allows investigation of a case with less gas exsolution.</p> <p>Package is also now pip installable.</p>"},{"location":"Changelog/#added","title":"Added","text":"<ul> <li>Tolerable supersaturation parameter. Used by ReducedEnthalpyMethod.</li> </ul>"},{"location":"Changelog/#changed","title":"Changed","text":"<ul> <li>Barrow initial condition initialises ocean with <code>far_gas_sat</code> so that ocean can be subsaturated with air.</li> <li>Made poetry a package managed by poetry with pyproject.toml so that it can be installed easily with pip.</li> </ul>"},{"location":"Changelog/#removed","title":"Removed","text":"<ul> <li>Remove requirements.txt as not needed now dependencies are in pyproject.toml.</li> </ul>"},{"location":"Changelog/#v0120-2024-01-30","title":"v0.12.0 (2024-01-30)","text":""},{"location":"Changelog/#summary_15","title":"Summary","text":"<p>Add the option to run simulations with phase averaged thermal conductivity to better match ice depth for real sea ice growth. We also add the functionality to run a single simulation config or a directory of simulation configs, which can be dimensional or not, from the command line using the <code>python -m celestine</code> command.</p>"},{"location":"Changelog/#added_1","title":"Added","text":"<ul> <li>Add parameters to the dimensional params configuration class so that a simulation configuration can be generated without supplying any additional objects.</li> <li>Add main.py file which uses argparse to run simulation configurations from the command line.</li> <li>Option to calculate conductive heat transfer using phase averaged thermal conductivities.</li> </ul>"},{"location":"Changelog/#changed_1","title":"Changed","text":"<ul> <li>Remove data_path as a configuration option and change solver methods to specify where they will save output.</li> <li>Flux module calculation to calculate phase average thermal conductivities.</li> </ul>"},{"location":"Changelog/#removed_1","title":"Removed","text":"<ul> <li>Remove tests/run_tests.py as tests can now be run from the command line using <code>python -m celestine test_data</code>.</li> </ul>"},{"location":"Changelog/#docs_1","title":"Docs","text":"<ul> <li>Update test procedure in README.</li> </ul>"},{"location":"Changelog/#v0110-2024-01-15","title":"v0.11.0 (2024-01-15)","text":""},{"location":"Changelog/#summary_16","title":"Summary","text":"<p>We have added options to the simulation to use a brine convection parameterisation (Rees Jones 2014). This desalinates the ice and brings in saturated ocean water, assuming continuity of velocity at the ice interface. This seems to work relatively well to desalinate the ice for the barrow simulation if we start with ocean bulk salinity. This however also changes the heat balance so to get the ice growth correct we need to use a thermal conductivity value that is an average of ice and water. Going forward we could just implement the full heat conduction term for each phase. To further improve the barrow simulation we use thermistor data for the ocean to force the bottom of the domain. We also give the option to use thermistor data at the ice snow interface to better match temperature evolution of the ice. This is better than the air temperature as we do not simulate the insulating layer of snow.</p>"},{"location":"Changelog/#added_2","title":"Added","text":"<ul> <li>Functionality to calculate the liquid velocity associated with brine convection using Rees Jones 2014 parameterisation by turning the brine_convection_parameterisation to True in the simulation configuration. The parameterisation should advect tracers with the broad upward liquid flow and also remove salt, heat and bulk gas via a sink term that appears as the downward brine channel flow. There are two more true/false flags that decide wether to couple bubble motion to the vertical flow that should move bubbles upward and to the horizontal flow which is responsible for transporting bubbles to brine channels where they would be expelled and so this appears in the sink term.</li> <li>Added configuration parameters needed for the brine convection parameterisation. The critical Rayleigh number, the convection strength tuning parameter and then the dimensional haline contraction coefficient and reference permeability. The two tuning parameters are given default values from the Rees Jones 2014 paper but later work (Thomas 2022) suggests using lower values of these will work better to desalinate the ice.</li> <li>test_brine_drainage.py This script is useful as it generates some plots illustrating the functions used to calculate the ice depth, rayleigh number and convecting liquid velocity. This can be used to visually confirm the parameterisation is working as expected and the templates for plotting these quantities may come in handy.</li> <li>drainage_test.py This script runs a simulation with the brine drainage parameterisation turned on.</li> <li>celestine/brine_drainage.py This module calculates the quantities needed for the Rees Jones 2014 brine convection parameterisation and provides the parameterised darcy liquid velocity to the rest of the simulation.</li> <li>celestine/brine_channel_sink_terms.py This module implements the loss of heat, salt and bulk gas through the downward brine channel flow in the Rees Jones 2014 convective parameterisation. This provides the terms in the conservation equations that loose heat, salt and bulk gas to the ocean.</li> <li>Added the option to choose the thermistor temperature data used to force the top of the simulation for the barrow simulation. This is important as we don't simulate a snow layer so we can choose via the new option Barrow_top_temperature_data_choice in the configuration if we want to use temperature data recorded at the air interface, bottom snow or top of ice.</li> <li>Added option in the barrow configuration to choose the bulk gas content of the initial ice cover.</li> </ul>"},{"location":"Changelog/#changed_2","title":"Changed","text":"<ul> <li>Make the barrow simulation configuration use recorded ocean temperature to force the bottom of the domain.</li> </ul>"},{"location":"Changelog/#docs_2","title":"Docs","text":"<ul> <li>Add the modules brine_drainage and brine_channel_sink_terms to the documentation index.</li> </ul>"},{"location":"Changelog/#bugs","title":"Bugs","text":"<ul> <li>The brine convection parameterisation seems to work but the option to couple bubbles to the horizontal flow and hence remove free gas phase via brine channels does not work as it seems some quantity is calculated on the wrong grid. This option currently just breaks the simulation if set to True.</li> </ul>"},{"location":"Changelog/#v0100-2023-11-24","title":"v0.10.0 (2023-11-24)","text":""},{"location":"Changelog/#summary_17","title":"Summary","text":"<p>To calculation of gas velocity we add options to use a different fit for wall drag enhancement function taken from a paper by Haberman. We also add the option to use a critical liquid velocity percolation threshold to cut off gas motion. We add some plots comparing different gas rise parameterisations.</p>"},{"location":"Changelog/#added_3","title":"Added","text":"<ul> <li>Alternative fit for wall drag enhancement as a function of scaled bubble radius taken from a paper by Haberman.</li> <li>parameters in config and non dimensional config to choose the type of wall drag funciton used.</li> <li>plot of different wall drag enhancement functions and bubble rise velocities against liquid fraction for different bubble distributions and drag laws.</li> <li>Add critical liquid fraction porosity cutoff of 2.4% from Maus paper.</li> <li>Add options to enable this cutoff, leave the default behaviour the same.</li> <li>Gas velocity plots comparing different bubble terminal rise velocities to Moreau 2014 paper.</li> </ul>"},{"location":"Changelog/#changed_3","title":"Changed","text":"<ul> <li>Values for pore throat radius and scaling taken from Maus paper for gas velocity plots. Before we were wrongly using diameter instead of radius.</li> <li>Change default value of dynamic liquid viscosity used in dimensional configuration to match the value of kinematic viscosity used in Moreau 2014 paper.</li> </ul>"},{"location":"Changelog/#v090-2023-11-12","title":"v0.9.0 (2023-11-12)","text":""},{"location":"Changelog/#summary_18","title":"Summary","text":"<p>This version adds the funcitonality to calculate the gas Darcy flux using the interstitial terminal rise velocity of a bubble averaged over a power law bubble size distribution. The default behaviour remains to use a single bubble size but parameters now exist for the power law case. The velocities module has also been refactored and in anticipation of parameterising the liquid flow instead of direct calculation the lagged upwind solver and funcitons for solving the pressure ODE are removed here.</p>"},{"location":"Changelog/#added_4","title":"Added","text":"<ul> <li>script called plot_gas_velocity.py to plot different versions of the calculated gas interstitial velocity against liquid fraction.</li> <li>Functions in the velocities module to calculate the gas interstitial velocity averaged over a power law distribution of bubble sizes.</li> <li>Parameters needed (dimesnional and non dimensional) to select either a single bubble size or power law distribution case. In the power law case added the maximum and minimum bubble sizes and the power law slope as parameters.</li> </ul>"},{"location":"Changelog/#changed_4","title":"Changed","text":"<ul> <li>Refactor calculation of gas interstitial velocity to make it possible to add options to calculate this with a monodispersed bubble size distribution or a power law distribution.</li> <li>The definition of the non dimensional buoyancy parameter B is changed to use the pore length scale as this doesn't change as we integrate over bubble size distributions.</li> </ul>"},{"location":"Changelog/#removed_2","title":"Removed","text":"<ul> <li>For simplicity we remove the functions which calculate liquid Darcy velocity from solving an ODE for the pressure at each timestep. These are not necessary for the reduced model approximation.</li> <li>Remove the lagged upwind solver which was the only one to attempt to use the pressure solve.</li> </ul>"},{"location":"Changelog/#docs_3","title":"Docs","text":"<ul> <li>Equation for calculation of gas bubble interstitial velocity is updated in the numerical method documentation.</li> </ul>"},{"location":"Changelog/#tests_1","title":"Tests","text":"<ul> <li>Remove test cases that use the now removed lagged upwind solver.</li> </ul>"},{"location":"Changelog/#v080-2023-05-23","title":"v0.8.0 (2023-05-23)","text":""},{"location":"Changelog/#summary_19","title":"Summary","text":"<p>This code can now generate a simulation configuration from dimensional parameter inputs. It can also convert the output to dimensional units for plots. It can also now run simulations with the \"barrow_2009\" forcing and initial conditions option which uses surface temperature data from the Barrow field station in 2009 to compare our simulation data to the field data of Zhou and Tison.</p>"},{"location":"Changelog/#added_5","title":"Added","text":"<ul> <li>Dimensional parameters module to handle input of dimensional parameters and converting between non dimensional and dimensional variables.</li> <li>Example script to run a simulation with Barrow 2009 Jan-Jun configuration called <code>barrow.py</code>.</li> <li>Barrow field station temperature data and metadata in <code>celestine/forcing_data/</code>. Must be read in to use \"barrow_2009\" temperature forcing option.</li> <li>Initial conditions module so we can use different initial conditions chosen in configuration.</li> <li>Method in Scales class to convert bulk air content into mircro moles of Argon per Liter of ice, under some assumptions that mass ratio of Argon in air is the same as in the atmosphere. This lets us compare to the field data for Argon of Zhou and Tison.</li> </ul>"},{"location":"Changelog/#docs_4","title":"Docs","text":"<ul> <li>Document explaining numerical methods used. </li> <li>README containing install instructions, how to run the tests, a breakdown of the documentation and checklist for creating a new release.</li> </ul>"},{"location":"Changelog/#v070-2023-05-19","title":"v0.7.0 (2023-05-19)","text":""},{"location":"Changelog/#summary_20","title":"Summary","text":"<p>This code is now capable of solving the reduced model configuration for the same forcing and boundary conditions as the full model. This is a set of approximations where the gas fraction is neglected in the enthalpy method and so no liquid flow is generated by gas motion, so we do not need to solve for the liquid pressure. The reduced model can be solved using a forward euler upwind scheme or using RK23 with scipy solve_ivp. As this includes adaptive timestepping this works well for simulations with high gas buoyancy. It is  important to note that as gas fraction is decoupled from solid and liquid fraction in the reduced model we must impose that gas cannot enter a cell which already contains high enough gas fraction to saturate the pore space.</p>"},{"location":"Changelog/#added_6","title":"Added","text":"<ul> <li>Reduced model classes for the phase boundaries, enthalpy method and solver. This is chosen with the solver choice \"RED\" in the simulation configuration.</li> <li>Solver class to solve the reduced model using the <code>scipy.integrate.solve_ivp</code> function with the RK23 method. This solver option is \"SCI\" in the simulation configuration.</li> </ul>"},{"location":"Changelog/#docs_5","title":"Docs","text":"<ul> <li>Add docs pages for the reduced model solver and the reduced model solver that uses <code>scipy.integrate.solve_ivp</code>.</li> </ul>"},{"location":"Changelog/#tests_2","title":"Tests","text":"<ul> <li>Include configurations with the two new solvers in the test cases.</li> </ul>"},{"location":"Changelog/#v060-2023-05-19","title":"v0.6.0 (2023-05-19)","text":""},{"location":"Changelog/#summary_21","title":"Summary","text":"<p>Can run only the lagged upwind solver (LU) for the full enthalpy method with constant or yearly surface temperature forcing with given initial state. A lot of broken or redundant code was removed from v0.5.0 and refactored to make it easier to extend adding reduced model as another enthalpy method and new solvers and boundary conditions.</p>"},{"location":"Changelog/#added_7","title":"Added","text":"<ul> <li>Helper function for grids to add ghost cells to a quantity on cell centers. This is very useful for applying boundary conditions.</li> <li>Module called flux to calculate fluxes for heat, salt and gas. This should make implementing new solvers easier and more reliable.</li> <li>Function for lagged upwind solver to take forward euler timestep given fluxes.</li> <li>State module for working with solution state at each timestep. Contains the State class for working with the solution on cell centers at each timestep and running the appropriate enthalpy method. StateBCs is responsible for adding the boundary conditions. Solution is responsible for storing the timesteps to be saved.</li> <li>Class interface for enthalpy method so we can implement different versions. The enthalpy method is picked from the solver choice in the configuration.</li> <li>Class interface for phase boundary calculation so we can implement difference versions.</li> </ul>"},{"location":"Changelog/#changed_5","title":"Changed","text":"<ul> <li>Refactor solver template and enthalpy method to use a state class.  This contains all the variables needed at a timestep so makes writing solvers more concise.</li> <li>Solver template uses solution class to store variables to be saved in a numpy array of fixed dimensions. This has better performance than appending to an array each time we want to save new data.</li> <li>Simplify boundary conditions module to just add a fixed condition to each variable we may need on the ghost grid. Then the StateBCs class handles adding these to the state at each timestep.</li> <li>Before boundary conditions were calculated by inverting the enthalpy method. Now we just impose appropriate values of temperature, dissolved gas etc... I have chosen to extrapolate the liquid fraction to the ghost cells as being equal to the top and bottom cell centers.</li> <li>Solution output of simulation is now given on the cell centers but can be easily extended to the ghost cells by using the StateBCs class.</li> <li>Initial solution is now uniform profile of enthalpy, bulk salt and bulk gas given by their given values at the bottom of the domain.</li> <li>Lagged Upwind solver uses new template solver interface.</li> <li>Velocities module now takes stateBCs object.</li> </ul>"},{"location":"Changelog/#docs_6","title":"Docs","text":"<ul> <li>Auto generate docstring documentation for each module using sphinx as <code>docs/manual.pdf</code>.</li> </ul>"},{"location":"Changelog/#tests_3","title":"Tests","text":"<ul> <li>Put tests in their own package <code>tests/</code>.</li> <li>Run different bubble sizes and constant/yearly forcing for only lagged upwind solver as test case. Record if the simulation runs or crashes.</li> </ul>"},{"location":"Changelog/#removed_3","title":"Removed","text":"<ul> <li>Implicit lax friedrich solver (LXFImplicit).</li> <li>Lax Friedrich solver (LXF).</li> <li>Other partially written solvers that I wasn't using.</li> <li>Adaptive timestepping option. This wasn't really being utilised and was making the code more opaque.</li> <li>Checks on initial timestep and grid size. Now just log a warning if Courant number for thermal diffusion exceeds 0.5 in the lagged upwind solver as this treats the diffusive term explicitly.</li> <li>Code to plot full enthalpy method phase space diagram from <code>celestine.phase_boundaries.py</code>.</li> <li>Code to plot enthalpy method quantities from <code>celestine.enthalpy_method.py</code>.</li> <li>Scripts to plot benchmark case for comparing the three solvers in v0.5.0.</li> </ul>"},{"location":"Changelog/#v050-2023-04-27","title":"v0.5.0 (2023-04-27)","text":""},{"location":"Changelog/#summary_22","title":"Summary","text":"<p>Runs full enthalpy method with three different solvers: - LU (forward euler explicit upwind scheme, calculate velocity from previous timestep) - LXF (forward euler explicit lax-friedrich scheme) - LXFImplicit (same as LXF but calculate heat diffusion implictly for better resolution)</p> <p>Contains benchmark scripts to compare these solvers during yearly temperature forcing run.</p> <p>Contains code in enthalpy_method and phase_boundaries to plot phase space diagrams.</p> <p>Contained artificial cut off in liquid darcy velocity calculation and all of the solvers suffer the same instability during melting part of yearly cycle.</p>"},{"location":"Changelog/#added_8","title":"Added","text":"<ul> <li>Options to forcing configuration to control sinusoidal yearly temperature forcing.</li> <li>LXFImplicit solver option which is the same as lax friedrich solver but uses backwards Euler for temperature diffusion terms. This relaxes timestep constraint so that grid can  be refined to investigate numerical diffusion introduced by this method.</li> <li>Scripts to generate benchmark configuration, run the simulations and plot the data. These scripts compare the LU, LXF and LXFImplicit solvers for a yearly temperature forcing run with micro bubbles and plot the profiles from the different solvers on the same axis to compare.</li> </ul>"},{"location":"Changelog/#changed_6","title":"Changed","text":"<ul> <li>Example simulation in main.py now plots solid fraction and temperature.</li> <li>Adaptive timestepping now controlled by flag in nuerical params object. Default is false so solve will just proceed with initial timestep.</li> <li>Calculate liquid Darcy velocity with permeability as the cube of liquid fraction. This reverts a change made to debug instability which I forgot about.</li> <li>Pressure solver regularisation increased from 1e-15 to 1e-4 so it can have more of an effect.</li> </ul>"},{"location":"Changelog/#tests_4","title":"Tests","text":"<ul> <li>Add LXFImplicit solver to manual testing cases.</li> </ul>"},{"location":"Changelog/#v040-2023-04-18","title":"v0.4.0 (2023-04-18)","text":""},{"location":"Changelog/#added_9","title":"Added","text":"<ul> <li>Lagged upwind solver as an option to use.</li> </ul>"},{"location":"Changelog/#changed_7","title":"Changed","text":"<ul> <li>Refactored solvers to use a template solver which handles common methods. Implemented solvers should inherit and overwrite the relevant methods.</li> </ul>"},{"location":"Changelog/#docs_7","title":"Docs","text":"<ul> <li>Specified a testing procedure to run for each release.</li> </ul>"},{"location":"Changelog/#tests_5","title":"Tests","text":"<ul> <li>Added script to generate test simulation config yaml files in <code>test_data/</code>.</li> <li>Added script to run test simulation config and log if any crash.</li> <li>This information can be recorded manually in the template file in <code>docs/</code>.</li> </ul>"},{"location":"Changelog/#v030-2023-04-17","title":"v0.3.0 (2023-04-17)","text":""},{"location":"Changelog/#added_10","title":"Added","text":"<ul> <li>Logging. Logs are generated for the simulation in main stating the version number and duration of the simulation stored in the logs/ directory.</li> </ul>"},{"location":"Changelog/#changed_8","title":"Changed","text":"<ul> <li>Split the Params class into multiple different classes. These are combined in the new Config class. </li> <li>Code refactored to use the Config class (only the lax friedrich solver not the others).</li> <li>Config object can be saved to and loaded from a yaml file not json.</li> </ul>"},{"location":"Changelog/#docs_8","title":"Docs","text":"<ul> <li>Added release checklist.</li> </ul>"},{"location":"Changelog/#removed_4","title":"Removed","text":"<ul> <li>Removed dependency on tqdm for progress bar.</li> </ul>"},{"location":"Changelog/#v020-2023-04-14","title":"v0.2.0 (2023-04-14)","text":""},{"location":"Changelog/#docs_9","title":"Docs","text":"<ul> <li>add requirements in requirements.txt file</li> </ul>"},{"location":"Changelog/#added_11","title":"Added","text":"<ul> <li>lax friedrich solver (still upwind enthalpy, boundary values and solid regions)</li> </ul>"},{"location":"Changelog/#removed_5","title":"Removed","text":"<ul> <li>remove dependency on scienceplots</li> </ul>"},{"location":"Changelog/#changed_9","title":"Changed","text":"<ul> <li>change yearly temperature forcing period to be 4 units of time</li> <li>function to compute cell edge values as arithmetic mean of centers</li> <li>main function just run one yearly simulation with small bubbles and plot gas fraction and bulk salinity for debugging</li> </ul>"},{"location":"Changelog/#v010-2023-04-13","title":"v0.1.0 (2023-04-13)","text":"<ul> <li>Simulate bubbles in a mushy layer in 1D using the enthalpy method with given surface forcing.</li> <li>Phase fractions of solid, liquid and gas must sum to one and so bubble nucleation and motion drives a liquid flow.</li> <li>Implemented a variety of implicit and semi-implicit solvers as calculating liquid velocity from pressure solver requires knowlege of gas fraction time derivative.</li> <li>Backward euler approach uses scipy root findding (krylov solver) to solve non linear system of residuals.</li> <li>Iterative solver performs a fixed point iteration for each timestep until residuals are suitably lows.</li> <li>Lagged solver assumes velocity calculated in between each timestep, this will introduce some error in the flow calculated.</li> </ul>"},{"location":"Changelog/#problems","title":"Problems","text":"<ul> <li>All of these methods seem to suffer instabilities when gas accumulates below an impermeable eutectic layer which melts as surface temperature forcing warms.</li> </ul>"}]}